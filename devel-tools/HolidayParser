#!/usr/bin/perl
# HolidayParser
# A parser of ~/.holiday-style files as found in the plan-distribution.
#  The format is based off of the holiday files found in the
#  plan-distribution and not any official spec. This because no
#  official spec could be found.
# Copyright (C) Eskild Hustvedt 2006
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

# The parser should spit out a perl hash based upon the holiday file found.
#
# A lot of the things in the holiday file is simply dropped.
# Generally we will have two modes for each holiday entry:
#  "red"
#  "none"
# Red is a special "red" day, while none is a normal day just
# ticked off. The keywords "red" and "weekend" counts as "red",
# all others count as "none"

use strict;
use warnings;
use POSIX;
use Data::Dumper;
$Data::Dumper::Purity = 1;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Indent = 1;


# Easter calculation using the gauss algorithm. See:
# http://en.wikipedia.org/wiki/Computus#Gauss.27s_algorithm
# Parts of the code stolen from Kenny Fowler
#
# Purpose: Calculate on which day easter occurs on in the year YEAR
# Usage: $EasterYDay = EasterCalc(YEAR);
# 
# YEAR should be absolute and not relative to 1900
sub EasterCalc ($) {
	my $year = $_[0];

	my $c;
	my $l;
	my $k;
	my $d;
	my $r;
	my $j;
	my $NewTime;
	
	$c = int($year/100);
	
	$l = $year % 19;
	
	$k = int(($c - 17)/25);
	
	$d = (15 + $c - int($c/4) - int(($c-$k)/3) + 19*$l) % 30;
	
	$r = $d - int(($d + int($l/11))/29);
	
	$j = ($year + int($year/4) + $r + 2 - $c + int($c/4)) % 7;

	my $number = 28 + $r - $j;

	if ($number > 31)
	{
		$number = $number - 31;
		$year = $year - 1900;
		$NewTime = POSIX::mktime(0, 0, 0, $number, 3, $year);
	} else {
		$year = $year - 1900;
		$NewTime = POSIX::mktime(0, 0, 0, $number, 2, $year);
	}
	my ($easter_sec,$easter_min,$easter_hour,$easter_mday,$easter_mon,$easter_year,$easter_wday,$easter_yday,$easter_isdst) = localtime($NewTime);
	return($easter_yday);
}

# Purpose: Calculate a NumericYDay
# Usage: $CreativeParser{FinalYDay} = HCalc_NumericYDay($CreativeParser{NumericYDay}, $CreativeParser{AddDays}, $CreativeParser{SubtDays});
sub HCalc_NumericYDay ($$$) {
	my ($DAY, $ADD_DAYS, $SUBTRACT_DAYS) = @_;
	if(defined($ADD_DAYS)) {
		$DAY += $ADD_DAYS;
	}
	if(defined($SUBTRACT_DAYS)) {
		$DAY -= $SUBTRACT_DAYS;
	}
	# mday begins on 1 not 0 - we use mday for all calculations, thus
	# make the day 1-365 instead of 0-364 here
	$DAY++;
	return($DAY);
}

# Purpose: Return the English day name of the year day supplied
# Usage: $DayName = Holiday_DayName(INTEGER_NUMBER, YEAR);
sub Holiday_DayName ($$) {
	my $year = $_[1];
	$year -= 1900;
	
	my $PosixTime = POSIX::mktime(0, 0, 0, $_[0], 0, $year);
	die("*** Holiday_DayName: For some reason mktime returned undef!. Was running: \"POSIX::mktime(0, 0, 0, $_[0], 0, $year)\".\nYou've probably got a loop that has started looping eternally. This error is fatal") unless(defined($PosixTime));
	my %NumToDayHash = (
		0 => 'sunday',
		1 => 'monday',
		2 => 'tuesday',
		3 => 'wednesday',
		4 => 'thursday',
		5 => 'friday',
		6 => 'saturday',
		7 => 'sunday',
	);
	my ($DayName_sec,$DayName_min,$DayName_hour,$DayName_mday,$DayName_mon,$DayName_year,$DayName_wday,$DayName_yday,$DayName_isdst) = localtime($PosixTime);
	return($NumToDayHash{$DayName_wday});
}

# Purpose: Return the yday of the supplied unix time
# Usage: $YDay = Get_YDay(UNIX_TIME);
sub Get_YDay ($) {
	my $Unix_Time = $_[0];
	warn("Get_YDay: Invalid usage: must be numeric. Got \"$Unix_Time\"") and return(undef) if $Unix_Time =~ /\D/;
	my ($get_sec,$get_min,$get_hour,$get_mday,$get_mon,$get_year,$get_wday,$get_yday,$get_isdst) = localtime($Unix_Time);
	return($get_yday);
}

# Purpose: Print a warning about some error during the holiday parsing
# Usage: HolidayError(LINE_NO, ERROR, ACTION_TAKEN);
sub HolidayError ($$$) {
	warn "*** Holiday parser error: $_[1] on line $_[0]. $_[2]\n";
}

# Purpose: Print a warning about something during the holiday parsing
# Usage: HolidayWarn(LINE_NO, ERROR, ACTION_TAKEN);
sub HolidayWarn ($$$) {
	warn "*** Holiday parser warning: $_[1] on line $_[0]. $_[2]\n";
}

# Purpose: Interperate and calculate the holiday file
# Usage: Holiday_Interperate(\%HashRef, Line_Number, HolidayName, YEAR);
sub Holiday_Interperate ($$$$) {
	my $CreativeParser = $_[0];
	my $LineNo = $_[1];
	my $HolidayName = $_[2];
	my $Year = $_[3];
	my %MonthMapping = (
		'january' => 0,
		'february' => 1,
		'march' => 2,
		'april' => 3,
		'may' => 4,
		'june' => 5,
		'july' => 6,
		'august' => 7,
		'september' => 8,
		'october' => 9,
		'november' => 10,
		'december' => 11,
	);	# Hash mapping the month name to a numeric
	
	if(defined($CreativeParser->{MustBeDay})) {

		# If IsMonth is defined then find a NumericYDay that we can use so that
		# the NumericYDay parsing below can do all of the heavy lifting
		if (defined($CreativeParser->{IsMonth})) {
			my $PosixYear = $Year - 1900;
			my $PosixTime = POSIX::mktime(0, 0, 0, 1, $MonthMapping{$CreativeParser->{IsMonth}}, $PosixYear);
			my $proper_yday = Get_YDay($PosixTime);
			if($CreativeParser->{Number} eq 'last') {
				# Find the first of the set day
				while(1) {
					if(Holiday_DayName($proper_yday, $Year) eq $CreativeParser->{MustBeDay}) {
						last;
					}
					$proper_yday++;
				}

				# Find the last of the set day
				my $Last_YDay = $proper_yday;
				while(1) {
					if(Holiday_DayName($proper_yday, $Year) eq $CreativeParser->{MustBeDay}) {
						$proper_yday += 7;
					}
					my $MKTime = POSIX::mktime(0, 0, 0, $proper_yday, 0, $PosixYear);
					die("mktime returned undef") unless(defined($MKTime));
					my ($detect_sec,$detect_min,$detect_hour,$detect_mday,$detect_mon,$detect_year,$detect_wday,$detect_yday,$detect_isdst) = localtime($MKTime);
					# If $detect_mon is not equal to $MonthMapping{$CreativeParser->{IsMonth}} then
					# we're now on the next month and have found the last of the day
					unless($detect_mon eq $MonthMapping{$CreativeParser->{IsMonth}}) {
						last;
					}
					$Last_YDay = $proper_yday;
				}
				$CreativeParser->{NumericYDay} = $Last_YDay;
				$CreativeParser->{BeforeOrAfter} = 'before';
			} else {
				# Parse the final
				$CreativeParser->{NumericYDay} = $proper_yday;
				if($CreativeParser->{Number} eq 'first') {
					$CreativeParser->{BeforeOrAfter} = 'after';
				} elsif($CreativeParser->{Number} eq 'second') {
					$CreativeParser->{BeforeOrAfter} = 'after';
					$CreativeParser->{AddDays} = 7;
				} elsif($CreativeParser->{Number} eq 'third') {
					$CreativeParser->{BeforeOrAfter} = 'after';
					$CreativeParser->{AddDays} = 14;
				} elsif($CreativeParser->{Number} eq 'fourth') {
					$CreativeParser->{BeforeOrAfter} = 'after';
					$CreativeParser->{AddDays} = 21;
				} else {
					die("FATAL: Internal error: \$CreativeParser->{Number} is $CreativeParser->{Number} - this is a bug!\n");
				}
			}

		}



		if(defined($CreativeParser->{NumericYDay})) {
			# Parse the main NumericYDay
			$CreativeParser->{FinalYDay} = HCalc_NumericYDay($CreativeParser->{NumericYDay}, $CreativeParser->{AddDays}, $CreativeParser->{SubtDays});
			# We don't know what to do with NumericYDays that has MustBeDay and IsMonth
			#	if(defined($CreativeParser->{IsMonth})) {
			#	HolidayError($LineNo, "The parser calculated a fixed day ($CreativeParser->{FinalYDay}) but a month was defined too", "Ignoring this line. This might be a bug in the parser");
			#	return(0);
			#}
			unless(defined($CreativeParser->{BeforeOrAfter})) {
				HolidayWarn($LineNo, "It was not defined if the day should be before or after", "Defaulting to before. This is likely to cause calculation mistakes.");
				$CreativeParser->{BeforeOrAfter} = 'before';
			}
			if($CreativeParser->{BeforeOrAfter} eq 'before') {
				# Before parsing
				# Okay, we need to find the closest $CreativeParser{MustBeDay} before $CreativeParser{FinalYDay}
				while (1) {
					if(Holiday_DayName($CreativeParser->{FinalYDay}, $Year) eq $CreativeParser->{MustBeDay}) {
						last;
					}
					$CreativeParser->{FinalYDay} = $CreativeParser->{FinalYDay} - 1;
				}
			} elsif ($CreativeParser->{BeforeOrAfter} eq 'after') {
				# After parsing
				# Okay, we need to find the closest $CreativeParser{MustBeDay} after $CreativeParser{FinalYDay}
				while (1) {
					if(Holiday_DayName($CreativeParser->{FinalYDay}, $Year) eq $CreativeParser->{MustBeDay}) {
						last;
					}
					$CreativeParser->{FinalYDay} = $CreativeParser->{FinalYDay} + 1;
				}
			} else {
				die("Fatal holiday parser error: BeforeOrAfter was set to an invalid value ($CreativeParser->{BeforeOrAfter}). This is a bug!");
			}
		} elsif (defined($CreativeParser->{IsMonth})) {
			unless(defined($CreativeParser->{DateNumeric}) or defined($CreativeParser->{Number})) {
				HolidayError($LineNo, "It was not defined when in the month this day should occur", "Ignoring this line.");
				return(0);
			}
			warn("TODO ISMONTH");
		} else {
			HolidayError($LineNo, "A day is defined but no other way to find out when the day is could be found", "Ignoring this line");
			return(0);
		}
	} 
	# Calculate the yday of that day-of-the-month
	elsif(defined($CreativeParser->{IsMonth})) {
		unless(defined($CreativeParser->{DateNumeric})) {
				HolidayError($LineNo, "No DateNumeric for IsMonth!", "Ignoring this line");
				return(0);
			}
		my $PosixYear = $Year - 1900;
		my $PosixTime = POSIX::mktime(0, 0, 0, $CreativeParser->{DateNumeric}, $MonthMapping{$CreativeParser->{IsMonth}}, $PosixYear);
		my $proper_yday = Get_YDay($PosixTime);
		$CreativeParser->{FinalYDay} = $proper_yday;
	} 
	# NumericYDay-only parsing is the simplest solution. This is pure and simple maths
	elsif(defined($CreativeParser->{NumericYDay})) {
		# NumericYDay-only parsing is the simplest solution. This is pure and simple maths
		if(defined($CreativeParser->{IsMonth})) {
			HolidayError($LineNo, "IsMonth is set but NumericYDay is too", "Parser confused. Ignoring IsMonth");
		}
		if(defined($CreativeParser->{MustBeDay})) {
			HolidayError($LineNo, "MustBeDay is set but NumericYDay is too", "Parser confused. Ignoring MustBeDay");

		}
		$CreativeParser->{FinalYDay} = HCalc_NumericYDay($CreativeParser->{NumericYDay}, $CreativeParser->{AddDays}, $CreativeParser->{SubtDays});
	}

	# Present the final calculation to the user (should create our hash)
	if(defined($CreativeParser->{FinalYDay})) {
		my $PosixYear = $Year - 1900;
		my $ScalarTime = localtime(POSIX::mktime(0, 0, 0, $CreativeParser->{FinalYDay}, 0, $PosixYear));
		chomp($ScalarTime);
		print "$HolidayName is on day $CreativeParser->{FinalYDay} the year $Year ($ScalarTime)\n";
	}
}

# Purpose: Load and parse the holiday file
# Usage: CalcHoliday(FILE, YEAR);
sub CalcHoliday ($$) {
	my $File = $_[0];
	my $Year = $_[1];
	
	# Validate year
	if($Year > 2037) {
		warn("Holiday parser: Can't count longer than 3037. Ignoring request for parsing of $File for the year $Year\n");
		return(0);
	}
	
	my $PosixYear = $Year;
	$PosixYear -= 1900;
	open(HOLIDAYFILE, "<$File") or die;
	my $LineNo;
	foreach my $Line (<HOLIDAYFILE>) {
		$LineNo++;
		next if $Line =~ /^\s*[:;#]/;# Ignore these lines
		next if $Line =~ /^\s*$/;# Ignore lines with only whitespace
		my $OrigLine = $Line;
		my $HolidayType;	# red or none (see above)
		
		my $LineMode;		# Is either PreDec or PostDec
					#  PreDec means that the holiday "mode" is declared before the name of
					#  the holiday.
					#
					#  PostDec means that the holiday "mode" is declared after the name
					#  of the holiday.
					#
					#  Note that PreDec incorporated the functions of PostDec aswell, but
					#  not the other way around
		if($Line =~ /^\s*\"/) {
			$LineMode = 'PostDec';
		} else {
			$LineMode = 'PreDec';
		}
	
		# Parse PreDec
		if($LineMode eq 'PreDec') {
			while(not $Line =~ /^\"/) {
				my $PreDec = $Line;
				$PreDec =~ s/^\s*(\w+)\s+.*$/$1/;
				chomp($PreDec);
				$Line =~ s/^\s*$PreDec\s+//;
				unless(length($PreDec)) {
						HolidayError($LineNo, "LineMode=PreDec, but the predec parser recieved \"$PreDec\" as PreDec", "Ignoring this predec");
					} else {
					if($PreDec =~ /^(weekend|red)$/) {
						$HolidayType = 'red';
					} elsif ($PreDec =~ /^(black|small|blue|green|cyan|magenta|yellow)$/) {
						# These are often just "formatting" declerations, and thus ignored by the day planner
						# parser. In these cases PostDec usually declares more valid stuff
						$HolidayType = 'none';
					} else {
						$HolidayType = 'none';
						HolidayError($LineNo, "Unrecognized holiday type: \"$PreDec\".", "Defaulting to 'none'");
					}
				}
			}
		}
	
		# Get the holiday name
		my $HolidayName = $Line;
		chomp($HolidayName);
		$HolidayName =~ s/^\s*\"(.*)\".*$/$1/;
		$Line =~ s/^\s*\".*\"//;
		if ($HolidayName =~ /^\"*$/) {
			HolidayError($LineNo, "Fatal, malformed line", "Ignoring this line.");
			next;
		}
	
		if ($Line =~ /^\s*(weekend|red|black|small|blue|green|cyan|magenta|yellow)/) {
			my $HolidayDec = $Line;
			$HolidayDec =~ s/^\s*(\w+)\s+.*$/$1/;
			chomp($HolidayDec);
			$Line =~ s/^\s*$HolidayDec\s+//;
			
			if($HolidayDec =~ /^(weekend|red)$/) {
				$HolidayType = 'red';
			} elsif ($HolidayDec =~ /^(black|small|blue|green|cyan|magenta|yellow)$/) {
				# These are often just "formatting" declerations, and thus ignored by the day planner
				# parser. However, if HolidayType already equals something else we ignore it
				unless(defined($HolidayType) and $HolidayType eq 'red') {
					$HolidayType = 'none';
				}
			} else {
				$HolidayType = 'none';
				HolidayError($LineNo, "Unrecognized holiday type: \"$HolidayDec\".", "Defaulting to 'none'");
			}
		}
		unless($Line =~ /^\s*on/) {
			HolidayError($LineNo, "Missing \"on\" keyword", "Pretending it's there. This might be a bug in the parser and might give weird effects");
		} else {
			$Line =~ s/^\s*on\*//;
		}

		# ==================================================================
		# Parse main keywords
		# ==================================================================
		
		# This is the hardest part of the parser, now we get creative. We read each word
		# and run it through the parser
		my %CreativeParser;
		foreach (split(/\s+/, $Line)) {
			next if /^\s*$/;
			if(/^(last|first|second|third|fourth)$/) {	# This is a number defining when a day should occur, usually used along with
									# MustBeDay (below)
				$CreativeParser{Number} = $_;
				next;
			} elsif (/^(monday|tuesday|wednesday|thursday|friday|saturday|sunday)$/) {	# This defines which day the holiday should occur on
				$CreativeParser{MustBeDay} = $_;
			} elsif (m#^\d+[/\.]\d+\.?$#) {		# This obscure regexp gets numbers in the format XX/YY X/Y, XX.YY and X.Y
								# With an optional trailing .
				my $day = $_;
				my $month = $_;
				$day =~ s/(\d+).*/$1/;
				$month =~ s#^\d+[/\.](\d+)\.?$#$1#;
				$month--;
				my $PosixTime = POSIX::mktime(0, 0, 0, $day, $month, $PosixYear);
				my ($new_sec,$new_min,$new_hour,$new_mday,$new_mon,$new_year,$new_wday,$new_yday,$new_isdst) = localtime($PosixTime);
				$CreativeParser{NumericYDay} = $new_yday;
			} elsif (/^(january|february|march|april|may|june|july|august|september|october|november|december)$/) {	# Which month it occurs in
				$CreativeParser{IsMonth} = $_;
			} elsif (/^plus$/) {			# If the next number should be added to a NumericYDay value
				$CreativeParser{NextIs} = 'add';
			} elsif (/^minus$/) {			# If the next number should be subtracted to a NumericYDay value
				$CreativeParser{NextIs} = 'sub';
			} elsif (/^length$/) {			# How long (in days) it lasts. FIXME: is currently ignored
				$CreativeParser{NextIs} = 'length';
			} elsif (/^easter$/) {			# The day of easter
				$CreativeParser{NumericYDay} = EasterCalc($Year);
			} elsif (/^weekend$/) {			# Malplaced weekend keyword
				$HolidayType = 'red';
			} elsif (/^\d+$/) {			# Any other number, see below for parsing
				# If NextIs is not defined then it's a DateNumeric
				unless(defined($CreativeParser{NextIs}) and $CreativeParser{NextIs}) {
					$CreativeParser{DateNumeric} = $_;
					next;
				}
	
				# Add to
				if($CreativeParser{NextIs} eq 'add') {
					if(defined($CreativeParser{AddDays})) {
						$CreativeParser{AddDays} = $CreativeParser{AddDays} + $_;
					} else {
						$CreativeParser{AddDays} = $_;
					}
				# Subtract from
				} elsif ($CreativeParser{NextIs} eq 'sub') {
					if(defined($CreativeParser{SubtDays})) {
						$CreativeParser{SubtDays} = $CreativeParser{SubtDays} + $_;
					} else {
						$CreativeParser{SubtDays} = $_;
					}
				# How long should it last?
				} elsif ($CreativeParser{NextIs} eq 'length') {
					if(defined($CreativeParser{Length})) {
						HolidayError($LineNo, "Multiple length statements", "Ignoring \"$_\"");
					} else {
						$CreativeParser{Length} = $_;
					}
				} else {
					# What on earth am I going to do with this number?
					HolidayError($LineNo, "Got a number ($_)", "I don't know what to do with this number");
				}
				$CreativeParser{NextIs} = undef;
				
			} elsif (/^(before|after)$/) {	# If a day should be before or after a certain day/date
				$CreativeParser{BeforeOrAfter} = $_;
			} elsif (/^(in|on|days|day|every)$/) {	# Ignored, just keywords for easier human parsing
				# FIXME: "every" might need to be taken into account
				next;
			} else {
				HolidayError($LineNo, "Unrecognized keyword \"$_\"", "Ignoring it. This might cause calculation mistakes! Consider using a combination of other keywords or report this as a bug to the author of this parser");
			}
		}
		
		unless(defined($CreativeParser{IsMonth}) or defined($CreativeParser{NumericYDay})) {
			HolidayError($LineNo, "No \"IsMonth\" nor \"NumericYDay\" after parsing", "Ignoring this line");
			next;
		}


		# ==================================================================
		# Interperate the file
		# ==================================================================

		Holiday_Interperate(\%CreativeParser, $LineNo, $HolidayName, $Year);
	}
}

# Temporary code to allow commandline invocation

die("Usage: $0 holiday_file\n") unless defined($ARGV[0]) and -e $ARGV[0];

my $CalcYear;

if(defined($ARGV[1])) {
	if ($ARGV[1] =~ /^\d+$/) {
		if($ARGV[1] < 1900) {
			die("Can't work with years lower than 1900\n");
		}
		$CalcYear = $ARGV[1];
	} else {
		die("The second parameter must be numeric\n");
	}
} else {
	 my ($year_sec,$year_min,$year_hour,$year_mday,$year_mon,$year_year,$year_wday,$year_yday,$year_isdst) = localtime(time);
	 $CalcYear = $year_year;
	 $CalcYear += 1900;
}

CalcHoliday($ARGV[0], $CalcYear);
