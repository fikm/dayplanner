#!/usr/bin/perl
# Dayplanner commander
# Copyright (C) Eskild Hustvedt 2006
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

use strict;			# Make my coding strict
use warnings;			# Enable perl warnings
use IO::Socket;			# Daemon communication
use Term::ReadLine;		# A more advanced way to get input than <STDIN>
use File::Basename;

my $socket;			# The socket

# Set up the signal handling
$SIG{PIPE} = sub { print "I recieved SIGPIPE - daemon shut down?\n"; };
$SIG{INT} = sub {
	if (defined($socket)) {
		print $socket "$$ BYE";
	}
	print("\n");exit(0);};

# The default socket
my $SocketName = "$ENV{HOME}/.dayplanner/dayplannerd";

# If $ARGV[0] is set then we want to connect to another socket
if(defined($ARGV[0]) and length($ARGV[0])) {
	if ($ARGV[0] =~ /^-(h|-help)/) {
		print "Usage: $0\n";
		print "   or: $0 /path/to/daemon/socket\n";
		print "\nThis is a tool to communicate with a day planner daemon directly\n";
		print "by sending raw commands to it and displaying the reply.\n";
		print "It has a simple builtin help system and handles initial connection,\n";
		print "authentication and adds the PID to the outgoing messages so that you don't\n";
		print "need to worry about that. This tool is mostly useful for debugging\n";
		exit(0);
	}
	$SocketName = $ARGV[0];
}
sub ConnectToDaemon () {
	# Verify socket existance
	unless (-e $SocketName) {
		die "$SocketName doesn't exist\n";
	}
	
	unless (-S $SocketName) {
		       if (-d $SocketName and -e "$SocketName/dayplannerd") {
				$SocketName = "$SocketName/dayplannerd";
			}
	}

	# Verify that it actually IS a socket
	unless (-S $SocketName) {
		die "$SocketName is not a socket\n";
	}

	# Open up the connection to the socket or die trying
	$socket = IO::Socket::UNIX->new(Peer	=> $SocketName,
	                                Type	=> SOCK_STREAM,
					Timeout	=> 10 )
	    or die "Couldn't connect to $SocketName: $@\nPerhaps the daemon isn't running?\n";
	
	# Say HI to the daemon and get the reply
	print $socket "$$ HI commander\n";
}
ConnectToDaemon();
my $HI_REPLY = <$socket>;

# Print initial warning and welcomming message
print "WARNING: Use with care, you have RAW access to the daemon and I\n will NOT stop you from destroying data!\n\n";
print "Welcome to the day planner daemon commander\n";
print "Type !QUIT to quit, !HELP to view known daemon commands\n";
print "Daemon says $HI_REPLY\n";

# Purpose: Print a nicely formatted help output for commands available
# Usage: CommandPrint(COMMAND, Description);
sub CommandPrint ($$) {
	printf "%-18s %s\n", $_[0], $_[1];
}

# Create our Term::ReadLine object
my $term = Term::ReadLine->new('Day Planner daemon commander');
# Get the attribs and set up autocompleteion
my $attribs = $term->Attribs;
$attribs->{completion_entry_function} = $attribs->{list_completion_function};
$attribs->{completion_word} = [qw(HI PING SHUTDOWN RELOAD_DATA BYE VERSION GET_PATH DEBUG DUMP_VARIOUS DUMP_CLIENTLIST DUMP_SLEEPTIME ENABLE_DEBUGLOG KICK !QUIT !HELP !RESTART_DAEMON)];

# An "eternal" loop getting input and parsing it
while (1) {
	# Get the input
	my $COMMAND = $term->readline('Command: ');
	# Make sure we got something other than emptyness or whitespace
	if(defined($COMMAND) and $COMMAND =~ /\S/) {
		chomp($COMMAND);			# Strip newlines
		if ($COMMAND =~ /^!QUIT/) {		# If it's !QUIT then tell the socket BYE and quit
			print $socket "$$ BYE\n";
		} elsif ($COMMAND =~ /^!HELP/) {	# If it's !HELP then we display the help
			print "\nList of internal commander commands:\n";
			CommandPrint("!QUIT", "Quit the commander");
			CommandPrint("!HELP", "Display this help screen");
			CommandPrint("!RESTART_DAEMON","Shut down the current daemon, start a new one and reconnect");
			print "\nList of known daemon commands:\n";
			CommandPrint("HI [client type]", "Initiate a new connection of type 'client type'");
			CommandPrint("", "client type can be \"commander\" (is always allowed)");
			CommandPrint("", "or \"client\" (the type dayplanner clients use");
			CommandPrint("", "only one client can be connected at any time)");
			CommandPrint("PING", "Send a simple PING request to see if the daemon is alive");
			CommandPrint("SHUTDOWN", "Tell the daemon to shut down");
			CommandPrint("RELOAD_DATA", "Tell the daemon to reload the calendar data");
			CommandPrint("BYE", "Tell the daemon to remove the client from its access lists");
			CommandPrint("VERSION", "Get the daemon version number");
			CommandPrint("GET_PATH", "Get the path used to start the daemon");
			CommandPrint("DEBUG [COMMAND]", "Run the debugging command [COMMAND]");
			print "\nList of debugging commands: (parameters to DEBUG)\n";
			CommandPrint("DUMP_VARIOUS", "Dump various useful information about the running daemon");
			CommandPrint("DUMP_CLIENTLIST", "Dump the list of connected PIDs");
			CommandPrint("DUMP_SLEEPTIME", "Dump approximately how long the daemon would sleep after");
			CommandPrint("", "this request has been processed (unless a new request is recieved).");
			CommandPrint("", "Returns the value in seconds as returned by the FindSleepDuration() function");
			CommandPrint("KICK [PID]", "Kick the PID specified from the daemon - denies further access until");
			CommandPrint("", "that PID reconnects (PID is removed from the access lists - its connection");
			CommandPrint("", "to the daemon stays open");
			CommandPrint("ENABLE_DEBUGLOG", "Enable logging of output to a file. The daemon will reply");
			CommandPrint("", "the path to the file it will output to");
		} elsif ($COMMAND =~ /^!RESTART_DAEMON/) {
			print "Restarting daemon...\n";
			print $socket "$$ GET_PATH\n";
			my $PATH = <$socket>;
			chomp($PATH);
			print $socket "$$ SHUTDOWN\n";
			my $REPLY = <$socket>;
			chomp($REPLY);
			unless($REPLY eq 'okay') {
				print "Failed to restart daemon, it replied \"$REPLY\" to my SHUTDOWN request\n";
			} else {
				print "Daemon shut down, starting a new one...\n";
				my $DaemonDir = dirname($SocketName);
				system("$PATH --force-fork --dayplannerdir $DaemonDir");
				ConnectToDaemon();
				my $RESTART_HI = <$socket>;
				chomp($RESTART_HI);
				print "A new daemon has been started. It says $RESTART_HI\n";
			}
		} else {				# Everything else we send unmodified to the daemon
			print $socket "$$ $COMMAND\n";
		}
		unless($COMMAND =~ /^(!HELP|!RESTART_DAEMON)/) {	# If the command isn't !HELP nor !RESTART_DAEMON then get and display the daemon reply
			my $REPLY = <$socket>;
			if (defined($REPLY)) {
				chomp($REPLY);
				print " Daemon replied: $REPLY\n";
			} else {
				print " Daemon didn't reply\n";
			}
			# Handle quitting the program
			if ($COMMAND =~ /^!QUIT/) {
				close($socket);
				exit(0);
			}
		}
	}
}

# Terminate the connection if we get this far, should never happen though
close($socket);
