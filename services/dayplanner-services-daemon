#!/usr/bin/perl
# dayplanner-services-daemon
# $Id$
# Copyright (C) Eskild Hustvedt 2006
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

# TODO: Maybe we should get -T enabled

use strict;
use warnings;
require 5.8.1;				# Require perl 5.8 to ensure things work smoothly
					# (5.8.1 introduced some security enhancements we need)
#use IO::Socket::SSL;	TODO: Implement this instead of IO::Socket::INET
use IO::Socket::INET;
use IO::Select;
use Getopt::Long;
use Digest::MD5 qw(md5_base64);
use Data::Dumper;
use Mail::Sendmail;
use Sys::Hostname;
use POSIX qw/cuserid/;

my $Server;
my $ConnectionSelect;
my $Shutdown;
my $OutputVeryVerbose = 1;
my $OutputVerbose = 1;
my $DebuggingOutput = 1;
my $Port = 4435;
my %ActiveUsers;
my %Clients;
my %Users;

# TODO: Not all user levels are fully functional
# level 0 = EXPIRED - no access at all
# level 1 = EXPIRED - read-only access
# level 2 = ACTIVE - rw access
# level 3 = ACTIVE - rw access
# level 4 = ADMIN - rw access and ADMIN command access

# TODO: Should be loaded from another file
my %Config = (
	DataPath => "./dpservices/",
	AdminMail => 'zerodogg@skolelinux.no',
	HTMLBase => "./public_html/",
	HTMLScript => "./GenHTML",
);

my $RCSRev = '$Id$';
my $Version = "0.3 ALPHA";

$SIG{INT} = sub {
	close($Server);
	print "Shutdown by SIG$_[0]\n";
	exit(0);
};
$SIG{TERM} = $SIG{INT};

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# CORE HELPER FUNCTIONS
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Purpose: Print formatted --help output
# Usage: PrintHelp("-shortoption", "--longoption", "description");
sub PrintHelp {
	printf "%-4s %-16s %s\n", "$_[0]", "$_[1]", "$_[2]";
}

# Purpose: Output a debugging message if needed
# Usage: IntDebug(MESSAGE);
sub IntDebug {
	if ($DebuggingOutput) {
		IntOutputMSG("DEBUG: $_[0]\n");
	}
}

# Purpose: Output a message when in very verbose mode
# IntVeryVerbose(MESSAGE);
sub IntVeryVerbose {
	if ($OutputVeryVerbose) {
		IntOutputMSG("$_[0]\n");
	}
}

# Purpose: Output a message when in verbose mode
# Usage: IntVerbose(MESSAGE);
sub IntVerbose {
	if ($OutputVerbose) {
		IntOutputMSG("$_[0]\n");
	}
}

# Purpose: Output a properly formatted internal message
# Usage: IntOutputMSG(MESSAGE);
sub IntOutputMSG {
	my ($lsec,$lmin,$lhour,$lmday,$lmon,$lyear,$lwday,$lyday,$lisdst) = localtime(time);
	$lhour = "0$lhour" unless $lhour >= 10;
	$lmin = "0$lmin" unless $lmin >= 10;
	$lsec = "0$lsec" unless $lsec >= 10;
	print "[$lhour:$lmin:$lsec] $_[0]";
}

# Purpose: Print a warning to STDERR with proper output
# Usage: IntWarn("Warning");
sub IntWarn {
	warn "Warning: $_[0]\n";
}

# Purpose: Set the program status
# Usage: SetStatus(STATUS);
sub SetStatus {
	$0 = "dayplanner-services-daemon port $Port [$_[0]]";
}

# Purpose: Write a configuration file
# Usage: WriteConfigFile(/FILE, \%ConfigHash, \%ExplanationHash);
sub WriteConfigFile {
	my ($File, $Config, $Explanations) = @_;

	# Open the config for writing
	open(my $CONFIG, ">", "$File") or do {
		# If we can't then we error out, no need for failsafe stuff - it's just the config file
		IntVerbose("Unable to save the configuration file $File: $!");
		return(0);
	};
	if(defined($Explanations->{HEADER})) {
		print $CONFIG "# $Explanations->{HEADER}\n";
	}
	foreach(sort(keys(%{$Config}))) {
		next unless length($Config->{$_});	# Don't write empty options
		if(defined($Explanations->{$_})) {
			print $CONFIG "\n# $Explanations->{$_}";
		}
		print $CONFIG "\n$_=$Config->{$_}\n";
	}
	close($CONFIG);
}

# Purpose: Load a configuration file
# Usage: LoadConfigFile(/FILE, \%ConfigHash, \%OptionRegexHash, OnlyValidOptions?);
#  OptionRegeXhash can be available for only a select few of the config options
#  or skipped completely (by replacing it by undef).
#  If OnlyValidOptions is true it will cause LoadConfigFile to skip options not in
#  the OptionRegexHash.
sub LoadConfigFile {
	my ($File, $ConfigHash, $OptionRegex, $OnlyValidOptions) = @_;

	open(my $CONFIG, "<", "$File") or do {
		print "Unable to read config settings: $File:$!\n";
		return(0);
	};
	while(<$CONFIG>) {
		next if m/^\s*(#.*)?$/;
		next unless m/=/;
		chomp;
		my $Option = $_;
		my $Value = $_;
		$Option =~ s/^\s*(.*)\s*=.*/$1/;
		$Value =~ s/^.*=\s*(.*)\s*/$1/;
		if($OnlyValidOptions) {
			unless(defined($OptionRegex->{$Option})) {
				IntVerbose("Unknown configuration option \"$Option\" in $File: Ignored.");
				next;
			}
		}
		unless(defined($Value)) {
			IntVerbose("Empty value for option $Option in $File");
		}
		if(defined($OptionRegex) and defined($OptionRegex->{$Option})) {
			my $MustMatch = $OptionRegex->{$Option};
			unless ($Value =~ /$MustMatch/) {
				print "Invalid setting of $Option in the config file: Must match $OptionRegex->{Option}.\n";
				next;
			}
		}
		$ConfigHash->{$Option} = $Value;
	}
	close($CONFIG);
}

# Purpose: Send an e-mail (sendmail() wrapper)
# Usage: SendMail(TO, SUBJECT, MESSAGE);
# 	Returns an error message on failure. undef otherwise
sub SendMail {
	my($To, $Subject, $Message) = @_;
	my %Message = (
		To => $To,
		From => "Day Planner services daemon <" . cuserid() . '@' . hostname() . ">",
		Subject => "[DPS] " . $Subject,
		Message => $Message,
		"X-Mailer" => "dayplanner-services-daemon//Mail::SendMail",
	);
	sendmail(%Message) or return($Mail::Sendmail::error);
	return(undef);
}

# Purpose: Notify the admin about data corruption
# Usage: DataCorruption(USER);
sub DataCorruption {
	my $User = $_[0];

	my $Error = SendMail(
		$Config{AdminMail},
		"Data corruption for user $User!",
		"The data for the user $User was found corrupt by the\nday planner services daemon at " . scalar(localtime(time)) . " on " . hostname() . ":$Port.\n\nThis error is very serious, please look into this as soon as possible\n\nRegards,\nthe day planner services daemon",
	);
	if($Error) {
		IntVerbose("WARNING: UNABLE TO SEND MAIL ABOUT DATA CORRUPTION: $Error");
	};
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# CORE DATA FUNCTIONS
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Purpose: Load the data
# Usage: LoadData();
sub LoadData {
	unless(-e "$Config{DataPath}/users.conf") {
		die("$Config{DataPath}/users.conf does not exist");
	}
	%Users = do("$Config{DataPath}/users.conf");
	return(1);
}

# Purpose: Get the data for a specific user
# Usage: $Returned = SendData(USER);
# 
# The returned data is like this:
# MD5_BASE64 BASE64_ENCODED_DPF_DATA
# The first part is the md5sum of the second part
sub SendData {
	my $User = $_[0];
	my %User_DataConfig;
	unless(-e "$Config{DataPath}/$User/dataconfig" and -e "$Config{DataPath}/$User/calendardata") {
		return("ERR NO_DATA");
	}

	LoadConfigFile("$Config{DataPath}/$User/dataconfig", \%User_DataConfig);

	open(my $User_Data, "<", "$Config{DataPath}/$User/calendardata") or return("ERR READFAIL $!");
	my $ReturnData = <$User_Data>;
	close($User_Data);
	unless(defined($User_DataConfig{LastMD5})) {
		return("ERR NO_MD5");
	}
	my $MD5 = md5_base64($ReturnData);
	if($MD5 eq $User_DataConfig{LastMD5}) {
		IntVerbose("Data for user $User sent");
		return("OK $MD5 $ReturnData");
	} else {
		IntVerbose("MD5 verification of data for the user $User failed! Wanted $User_DataConfig{LastMD5} but found $MD5.");
		DataCorruption($User);
		return("ERR MD5_FAILURE");
	}
}

# Purpose: Recieve new data for a specific user
# Usage: $Returned_Status = RecieveData(DATA,USER);
sub RecieveData {
	my $User = $_[1];
	my $Data = $_[0];
	my $THIS_MD5 = $_[0];
	my $LAST_MD5 = $_[0];
	my $FORCE = $_[0];	# NOTE: Use of FORCE is dangerous!
	my %User_DataConfig;

	$THIS_MD5 =~ s/^(\S+)\s+.*$/$1/;
	$LAST_MD5 =~ s/^(\S+)\s+(\S+).*$/$2/;
	$Data =~ s/^(\S+)\s+(\S+)\s+(\S+).*$/$3/;
	$FORCE =~ s/^(\S+)\s+(\S+)\s+(\S+)\s*//;
	unless(length($THIS_MD5) and length($LAST_MD5) and length($Data)) {
		return("ERR FORMATERROR");
	}

	LoadConfigFile("$Config{DataPath}/$User/dataconfig", \%User_DataConfig);
	
	unless($FORCE) {
		if(defined($User_DataConfig{LastMD5})) {
			unless($User_DataConfig{LastMD5} eq $LAST_MD5) {
				return("ERR LASTMD5_NOMATCH $User_DataConfig{LastMD5} - $LAST_MD5");
			}
		}
	}

	my $MD5 = md5_base64($Data);
	unless($MD5 eq $THIS_MD5) {
		return("ERR MD5_MISMATCH # $MD5 - $THIS_MD5");
	}

	# We got this far, write the data
	open(my $OutData, ">", "$Config{DataPath}/$User/calendardata") or do {
		IntVerbose("Unable to open $Config{DataPath}/$User/calendardata for writing!: $!");
		return("ERR WRITEFAILURE");
	};
	print $OutData $Data;
	close($OutData);
	
	$User_DataConfig{LastMD5} = $MD5;

	my %ConfigInfo = (
		LastMD5 => "The MD5 sum of the last data transmitted to the server for this user",
		HEADER => "Data information for $User",
	);

	WriteConfigFile("$Config{DataPath}/$User/dataconfig", \%User_DataConfig, \%ConfigInfo);
	IntVerbose("New data for user $User recieved");
	GenHTML($User);
	return("OK");
}

# Purpose: Get the MD5 sum of a users data
# Usage: $Returned = GetMD5(USER);
sub GetMD5 {
	my $User = $_[0];
	my %User_DataConfig;
	LoadConfigFile("$Config{DataPath}/$User/dataconfig", \%User_DataConfig);
	if(defined($User_DataConfig{LastMD5})) {
		return($User_DataConfig{LastMD5});
	} else {
		return("[NONE]");
	}
}

# Purpose: Generate HTML of a users data if needed
# Usage: GenHTML(USER);
sub GenHTML {
	my $User = shift;
	my $Language;
	unless($Users{$User}{settings}{GenHTML}) {
		return(1);
	}
	unless(-d $Config{HTMLBase}) {
		IntDebug("\$Config{HTMLBase} is not set");
		return(undef);
	}
	unless(-x $Config{HTMLScript}) {
		IntDebug("\$Config{HTMLScript} is not valid");
		return(undef);
	}
	if(defined($Users{$User}{settings}{language})) {
		$Language = $Users{$User}{settings}{language};
	} else {
		$Language = "en";
	}
	system("$Config{HTMLScript} --dir '$Config{HTMLBase}/$User' --user $User --pass $Users{$User}{password} --dpfsource '$Config{DataPath}/$User/calendardata' --language $Language");
	IntDebug("Started HTML generating script for user $User: $Config{HTMLScript} --dir '$Config{HTMLBase}/$User' --user $User --pass [HIDDEN] --dpfsource '$Config{DataPath}/$User/calendardata' --language $Language");
	return(1);
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# CORE SERVER FUNCTIONS
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Purpose: Handle commands
# Usage: CommandHandler(COMMAND, HANDLE);
sub CommandHandler {
	my ($Command, $Handle) = @_;
	chomp($Command);
	
	# API Level
	if($Command =~ /^APILEVEL/) {
		my $API = $Command;
		$API =~ s/^APILEVEL\s+(\d+).*$/$1/;
		unless($API eq "0") {
			return("ERR Unsupported");
		} else {
			$Clients{$Handle}{APIOK} = 1;
			return("OK");
		}
	}
	unless(defined($Clients{$Handle}{APIOK})) {
		return("REFUSED NO_APILEVEL");
	}

	# Authentication
	if($Command =~ /^AUTH/) {
		if(defined($Clients{$Handle}{User})) {
			return("REFUSED ALREADY_AUTHED $Clients{$Handle}{User}");
		}
		# Get the username and password parts
		my $Username = $Command;
		$Username =~ s/^AUTH\s*(\w+)\s+(\w+).*$/$1/;
		my $Password = $Command;
		$Password =~ s/^AUTH\s*(\w+)\s+(\w+).*$/$2/;
		
		# Verify supplied data
		unless(defined($Users{$Username})) {
			IntVeryVerbose("$Handle tried to auth as $Username, but that user doesn't exist");
			return("FAILED");
		}
		unless($Users{$Username}{password} eq $Password) {
			IntVerbose("Authentication from $Handle failed as $Username");
			return("FAILED");
		}
		# Make sure it's not in use
		if(defined($ActiveUsers{$Username}) and defined($ActiveUsers{$Username}{Handle})) {
			IntDebug("$Handle tried to auth as $Username but $ActiveUsers{$Username}{Handle} is authenticated as that user already");
			return("REFUSED IN_USE");
		}

		# If the user's level is 0 then the user account is expired and we refuse the login.
		if($Users{$Username}{level} eq "0") {
			return("EXPIRED");
		}
		$Clients{$Handle}{User} = $Username;
		$ActiveUsers{$Username}{Handle} = $Handle;
		IntVerbose("$Handle authenticated as $Username");
		return("OK");
	}
	# Require authentication to proceed
	unless(defined($Clients{$Handle}{User})) {
		return("REFUSED AUTHFIRST");
	}

	# Other commands
	if($Command =~ /^GETDATA/) {
		return(SendData($Clients{$Handle}{User}));
	} elsif($Command =~ s/^SENDDATA\s*//) {
		if($Users{$Clients{$Handle}{User}}{level} > 1) {
			return(RecieveData($Command, $Clients{$Handle}{User}));
		} else {
			return("EXPIRED");
		}
	} elsif($Command =~ /^GET_MD5/) {
		return(GetMD5($Clients{$Handle}{User}));
	} elsif($Command =~ s/^ADMIN\s+//) {
		if($Users{$Clients{$Handle}{User}}{level} == 4) {
			return(AdminCommands($Command));
		} else {
			return("REFUSED");
		}
	}
	IntVeryVerbose("Unknown command from " . $Handle->peerhost() . " ($Handle): $Command");
	return("ERR UNKNOWN_COMMAND");
}

# Purpose: Handle ADMIN commands
# Usage: AdminCommands(COMMAND, HANDLE);
sub AdminCommands {
	my ($Command, $Handle) = @_;
	if($Command =~ /^VERSION/) {
		return("$Version - $RCSRev");
	} elsif ($Command =~ /^RELOAD_USERLIST/) {
		IntVerbose("Userlist reloaded");
		LoadData();
		return("DONE");
	}
	return("ERR UNKNOWN_COMMAND");
}

# Purpose: Open our main communication socket
# Usage: OpenSocket();
sub OpenSocket {
	$Server = IO::Socket::INET->new(
					LocalPort => $Port,
					Listen	=> 5,
					Timeout => 15,		# We can't really wait longer as other users might want to connect
			) or die "Unable to create a new socket: $@\n";
	# Trap SIGPIPE
	$SIG{PIPE} = \&SigpipeHandler;
	# Create a new select handle for reading
	$ConnectionSelect = IO::Select->new();
	# Add the main server
	$ConnectionSelect->add($Server);
}

# Purpose: Start the main loop
# Usage: MainLoop();
# Requires: OpenSocket(); already performed
sub MainLoop {
	# Loop for eternity
	while (1) {
		SetStatus("waiting for connections");
		# Block until one handle is available or it times out
		my @Ready_Handles = $ConnectionSelect->can_read();
		SetStatus("processing");
		# For each handle...
		foreach my $Handle (@Ready_Handles) {
			# If the handle is $server then it's a new connection
			if ($Handle eq $Server) {
				my $NewClient = $Server->accept();
				$ConnectionSelect->add($NewClient);
				IntDebug("New connection from " . $NewClient->peerhost . " on $NewClient");
			} 
			# Handle isn't $server, it's an existing connection trying to tell us something
			else {
				# What is it trying to tell us?
				my $Command = <$Handle>;
				# If it is defined then it's a command
				if ($Command) {
					chomp($Command);
					my ($Reply) = CommandHandler($Command, $Handle);
					print $Handle "$Reply\n";
				} 
				# If it isn't, then it closed the connection
				else {
					if(defined($Clients{$Handle}{User})) {
						IntDebug("Connection closed for user $Clients{$Handle}{User} ($Handle)");
						delete($ActiveUsers{$Clients{$Handle}{User}});
					} else {
						IntDebug("Connection closed for $Handle");
					}
					delete($Clients{$Handle});
					$ConnectionSelect->remove($Handle);
				}
			}
		}
		if ($Shutdown) {
			IntVerbose($Shutdown);
			exit(0);
		}
	}
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# INITIALIZATION
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

GetOptions (
	'port|p=i' => \$Port,
	'help|h' => sub {
		print "Day planner services daemon version $Version\n\n";
		PrintHelp("-d", "--dayplannerdir", "Which directory to use as the dayplanner config dir");
		PrintHelp("", "--version", "Display version information and exit");
		PrintHelp("-h,", "--help", "Display this help screen");
		PrintHelp("-n,", "--nofork", "Don't go into the background (and log to STDOUT/STDERR instead of the logfile)");
		PrintHelp("-v,", "--verbose", "Be verbose");
		PrintHelp("-V,", "--veryverbose", "Be very verbose");
		PrintHelp("-D,", "--debug", "Output debugging information");
		exit(0);
	},
	'debug|D' => sub {
		$DebuggingOutput = 1;
		$OutputVerbose = 1;
		$OutputVeryVerbose = 1;
	},
	'verbose|v' => \$OutputVerbose,
	'veryverbose|V' => sub {
		$OutputVerbose = 1;
		$OutputVeryVerbose = 1;
	},
	'version' => sub {
		print "Day planner services daemon version $Version\n";
		print "RCS revision: $RCSRev\n";
		exit(0);
	},
) or die "See $0 --help for more information\n";

print "WARNING: This is alpha software. Use at your own risk. See README for more information\n\n";

SetStatus("starting");
LoadData();
OpenSocket();
MainLoop();
