#!/usr/bin/perl
# Day planner
# A graphical day planner written in perl that uses Gtk2
# Copyright (C) Eskild Hustvedt 2006
# $Id$
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

use strict;			# Force strict coding
use warnings;			# Tell perl to warn about things
use Locale::gettext;		# Allow the program to be translated
use POSIX;			# We need strftime
use Gtk2; 			# Use Gtk2 :)
use Data::Dumper;		# Our save format is that of Data::Dumper
use Gtk2::SimpleList;		# We use Gtk2::SimpleList to create the eventlist
use Gtk2::Gdk::Keysyms;		# Easier keybindings
use Getopt::Long;		# Commandline options
use Cwd;			# We need Cwd::Realpath to find out which directory we live in
use File::Basename;             # We meed dirname to help Cwd::Realpath finding the directory
use IO::Socket;			# Network layer to communicate with the daemon
use FindBin;			# So that we can detect module dirs during runtime
# So that we can use a local Date::HolidayParser
use lib "$FindBin::Bin/modules/Date-HolidayParser/lib/";
use lib "$FindBin::Bin/modules/";
use Date::HolidayParser;	# Parsing of .holiday files

# Scalars
my $Version = "0.2";
my $RCSRev = '$Id$';
my $SoftwareDir = dirname(Cwd::realpath($0));
my $SaveToDir = "$ENV{HOME}/.dayplanner";		# The configuration and eventlist directory
my $MainEventsFile = "events.dpd";			# The filename to save the events to
my $BirthdayFile = "birthdays.dpd";			# The filename to save birthdays to
my $SpecialEventsFile = "special_events.dpd";		# The filename to save events with special settings
my $AllDayEventsFile = "allday_events.dpd";		# The filename to save all-day events to
my $ConfigFile = "dayplanner.conf";			# The filename to save the configuration to
my $Gettext = Locale::gettext->domain("dayplanner");	# Set the gettext domain
my $DaemonName = 'dayplanner-daemon';			# The name of the daemon
my $DaemonOnline = 0;					# Is the daemon online?
my $DaemonInitialized = 0;				# Has the daemon been initialized?
my $DaemonSocketName = 'dayplannerd';			# The name of the daemon socket
my $DaemonSocket;					# The variable to connect to

setlocale(LC_ALL, "" );
textdomain("dayplanner");

# Find out if we have a locale directory in our main dir
if (-d "$SoftwareDir/locale/") {
	if(defined($ENV{LC_ALL}) or defined($ENV{LANG})) {
		my $I18N;
		if(defined($ENV{LC_ALL}) and length($ENV{LC_ALL})) {
			$I18N = $ENV{LC_ALL};
		} else {
			$I18N = $ENV{LANG};
		}
		if($I18N =~ /:/) {
			$I18N =~ s/^(.+):.*$/$1/;
		}
		if (-e "$SoftwareDir/locale/$I18N/LC_MESSAGES/dayplanner.mo") {
			bindtextdomain("dayplanner", "$SoftwareDir/locale");
		}
	}
}

# If for some obscure reason HOME isn't set we can't continue
unless(defined($ENV{HOME}) and $ENV{HOME}) {
	die(sprintf($Gettext->get("The environment variable %s is not set! Unable to continue\n"), "HOME"));
}
# The same goes for if HOME doesn't exist or isn't a directory
unless(-e $ENV{HOME} and -d $ENV{HOME}) {
	die sprintf($Gettext->get("Your home directory (%s) doesn't exist! Please verify that the environment variable %s is properly set. Unable to continue\n"), $ENV{HOME}, "HOME");
}

# Arrays
my @SaveFallbackDirs = (				# The directories to use for fallback saving if we can't save to $SaveToDir
	$ENV{HOME}, "$ENV{HOME}/Desktop", "$ENV{HOME}/Documents", "$ENV{HOME}/tmp", "/tmp", "/var/tmp", "/usr/tmp"
);

# Hashes
my %CalendarContents;		# The contents of the main calendar
my %BirthdayContents;		# The contents of the birthday file
my %SpecialEvents;		# The contents of the special events file
my %AllDayEvents;		# The contents of the all-day events file

# The reason we do not use strftime() or I18N::Langinfo is that these return
# values in random encodings. By using Gettext->get() we get values
# in a proper encoding
my %MonthNames = (
	1 => $Gettext->get("January"),
	2 => $Gettext->get("February"),
	3 => $Gettext->get("March"),
	4 => $Gettext->get("April"),
	5 => $Gettext->get("May"),
	6 => $Gettext->get("June"),
	7 => $Gettext->get("July"),
	8 => $Gettext->get("August"),
	9 => $Gettext->get("September"),
	10 => $Gettext->get("October"),
	11 => $Gettext->get("November"),
	12 => $Gettext->get("December")
);	# Localized hash of month number => Name values

# Gtk2 objects
my (
	$CalendarWidget,	$EventlistWidget,	$WorkingAreaHBox,
	$EventlistWin,		$MainWindow,		$Toolbar,
	$ToolbarEditButton
);	# Gtk objects

# Global date variables
my (
	$currsec,$currmin,$currhour,$currmday,$currmonth,$curryear,$currwday,$curryday,$currisdst
);

# Configuration options
my (
	$EditorVerboseDefault,	$Events_NotifyPre,
	$Events_NotifyDay,	$Events_DayNotify
);

# Window state
my ($MainWin_Width, $MainWin_Height) = (600,300);
my $MainWin_Maximized;

# Set up signal handlers
$SIG{INT} = \&DP_SigHandler;
$SIG{TERM} = \&DP_SigHandler;


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Networking functions
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Purpose: Initialize and connect to the daemon
# Usage: DaemonInit();
sub DaemonInit () {
	$DaemonInitialized = 1;
	
	# Handle SIGPIPE
	$SIG{PIPE} = \&DaemonSIGPIPEHandler;

	if (-e "$SaveToDir/$DaemonSocketName") {
		my $ConnectionAttempt = ConnectToDaemon("$SaveToDir/$DaemonSocketName");
		if ($ConnectionAttempt eq 'NOHI') {
			DaemonConnectionErrorHandler();
			return(1);
		} elsif ($ConnectionAttempt eq '1') {
			$DaemonOnline = 1;
			return(1);
		} 
	}
	return(StartDaemon());
}

# Purpose: Start the day planner daemon
# Usage: StartDaemon();
sub StartDaemon {
	foreach(split(/:/, sprintf("%s:%s", dirname(Cwd::realpath($0)), $ENV{PATH} ))) {
		if (-x "$_/$DaemonName") {
			# Yes this is a bit weird statement. But remember that commands return 0 on TRUE
			# and 1-255 on FALSE, so it's the other way around from perl
			unless(system("$_/$DaemonName --force-fork --dayplannerdir $SaveToDir")) {
				if(ConnectToDaemon("$SaveToDir/$DaemonSocketName")) {
					$DaemonOnline = 1;
					return(1);
				}
			}
		}
	}
	DPIntWarn("Unable to start daemon!");
	return(0);
}

# Purpose: Handle SIGPIPE gracefully
# Usage: $SIG{PIPE} = \&DaemonSIGPIPEHandler;
sub DaemonSIGPIPEHandler() {
	DPIntWarn("I recieved a SIGPIPE, the daemon is probably offline");
	StartDaemon();
}

# Purpose: Connect to the daemon
# Usage: ConnectToDaemon(/path/to/socket);
sub ConnectToDaemon ($$) {
	my $HI = 'HI client';
	if(defined($_[1]) and $_[1] eq 'FORCE') {
		$HI = 'HI client FORCE';
	}
	$DaemonSocket = IO::Socket::UNIX->new(
		Peer	=> $_[0],
		Type	=> SOCK_STREAM,
		Timeout	=> 5)
		or return("NOCONNECT");
	$DaemonOnline = 1;
	if(Daemon_DataSegment($HI) eq "HI\n") {
		return(1);
	} else {
		$DaemonOnline = 0;
		close($DaemonSocket);
		return("NOHI");
	}
}

# Purpose: Send some data to the daemon
# Usage: Daemon_SendData(DATA);
sub Daemon_SendData ($) {
	if($DaemonOnline) {
		unless(defined($DaemonSocket)) {
			DPIntWarn("BUG!: \$DaemonSocket is undefined");
			return(0);
		}
		if(print $DaemonSocket "$$ $_[0]","\n") {
			       return(1);
		       } else {
				DPIntWarn("Problem sending data to the daemon: $!");
		}
	} 
	return(0);
}

# Purpose: Get some data from the daemon
# Usage: $Data = Daemon_GetData();
sub Daemon_GetData {
	if($DaemonOnline) {
		unless(defined($DaemonSocket)) {
			DPIntWarn("BUG!: \$DaemonSocket is undefined");
			return("ERR UNABLE_TO_GET_DATA");
		}
		my $Data = <$DaemonSocket>;
		unless(defined($Data)) {
			return("ERR UNABLE_TO_GET_DATA");
		}
		return($Data);
	} else {
		return("ERR NOT_ONLINE");
	}
}

# Purpose: Send something to the daemon and then return the daemons reply
# Usage: $Reply = Daemon_DataSegment(DATA);
sub Daemon_DataSegment ($) {
	if($DaemonOnline) {
		if(Daemon_SendData($_[0])) {
			return(Daemon_ErrorHandler(Daemon_GetData()));
		}
	} else {
		return("ERR NOT_ONLINE");
	}
}

# Purpose: Close the connection to the daemon
# Usage: CloseDaemon();
sub CloseDaemon () {
	if ($DaemonOnline) {
		unless(defined($DaemonSocket)) {
			DPIntWarn("BUG!: \$DaemonSocket is undefined");
			return(1);
		}
		my $GetDaemon = Daemon_DataSegment('BYE');
		close($DaemonSocket);
		$DaemonOnline = 0;
	}
	return(1);
}

# Purpose: Display an error message when an error is recieved from the daemon
# Usage: Daemon_ErrorHandler(Daemon_GetData());
sub Daemon_ErrorHandler {
	if ($_[0] =~ /^ERR\s+/) {
		DPIntWarn("Recived error from daemon: \"$_[0]\"");
	}
	if(defined($_[1])) {
		DPIntWarn("Weird multi-return response from caller: [1]=\"$_[1]\"");
	}
	return($_[0]);
}

# Purpose: Display an error dialog about the inability to connect to the daemon
# Usage: DaemonConnectionErrorHandler();
sub DaemonConnectionErrorHandler () {
	my $ErrorDialog = Gtk2::MessageDialog->new (undef,
						'destroy-with-parent',
						'error',
						'none',
						 $Gettext->get("Another instance of day planner appears to be running. Please quit the currently running instance of day planner before continuing\n\nRunning two instances of day planner can be forced. However that is not recommended as it may lead to data loss or corruption."));

	$ErrorDialog->add_buttons(
		$Gettext->get('Force') => 'reject',
		'gtk-ok' => 'accept',
	);
	
	$ErrorDialog->set_default_response('accept');
	if($ErrorDialog->run eq 'accept') {
		$ErrorDialog->destroy;
		exit(0)
	} else {
		$ErrorDialog->destroy;
		unless (ConnectToDaemon("$SaveToDir/$DaemonSocketName", 'FORCE')) {
				DPError($Gettext->get("I was unable to force the start. This is likely due to a bug in the program, please contact the day planner developers."));
				exit(1);
			}
	}
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Data and configuration file functions
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Purpose: Write the state file 
# Usage: WriteStateFile(DIRECTORY, FILENAME);
sub WriteStateFile($$) {
	# The parameters
	my $Dir = $_[0];
	my $File = $_[1];

	unless(defined($MainWindow)) {
		DPIntWarn("Unable to save window state: The main window object is undef!");
		return(0);
	}
	
	# Open the config
	open(STATE, ">$Dir/$File") or do {
		# If we can't then we error out, no need for failsafe stuff - it's just the config file
		DPIntWarn("Unable to save window state to $Dir/$File: $!");
		return(0);
	};
	if(defined($MainWin_Maximized) and $MainWin_Maximized =~ /maximized/) {
		$MainWin_Maximized = 1;
	} else {
		$MainWin_Maximized = 0;
		($MainWin_Width, $MainWin_Height) = $MainWindow->get_size();
	}

	print STATE "# This file contains the saved state of the day planner window.\nMainWin_Width=$MainWin_Width\nMainWin_Height=$MainWin_Height\nMainWin_Maximized=$MainWin_Maximized\n";
	close(STATE);
}

# Purpose: Load the state file
# Usage: LoadStateFile(DIRECTORY, FILENAME);
sub LoadStateFile($$) {
	# The parameters
	my $Dir = $_[0];
	my $File = $_[1];

	
	# Open the statefile
	open(STATE, "<$Dir/$File") or do {
		return(1);
	};
	
	# Load the config
	foreach(<STATE>) {
		next if m/^\s*#/;
		next unless m/=/;
		chomp;
		my $Option = $_;
		my $Value = $_;
		$Option =~ s/^\s*(.*)\s*=.*/$1/;
		$Value =~ s/^.*=\s*(.*)\s*/$1/;
		unless($Value =~ /^\d+$/) {
			DPIntWarn("Invalid nondigit value for $Option in the statefile: $Value. Ignoring setting.");
			next;
		}
		if($Option eq 'MainWin_Width') {
			$MainWin_Width = $Value;
		} elsif ($Option eq 'MainWin_Height') {
			$MainWin_Height = $Value;
		} elsif ($Option eq 'MainWin_Maximized') {
			$MainWin_Maximized = $Value;
		} else {
			DPIntWarn("Invalid setting in the statefile: $Option (=$Value). Ignoring.");
			next;
		}
	}
	close(STATE);
}

# Purpose: Write the configuration file
# Usage: WriteConfig(DIRECTORY, FILENAME);
sub WriteConfig ($$) {
	# The parameters
	my $Dir = $_[0];
	my $File = $_[1];
	# Open the config
	open(CONFIG, ">$Dir/$File") or do {
		# If we can't then we error out, no need for failsafe stuff - it's just the config file
		DPError($Gettext->get(sprintf("Unable to save the configuration settings to %s: %s", "$Dir/$File", $!)));
		return(0);
	};
	# Verify the options first
	unless(defined($EditorVerboseDefault) and length($EditorVerboseDefault)) {
		$EditorVerboseDefault = 0;
	}
	unless(defined($Events_NotifyPre) and length($Events_NotifyPre)) {
		$Events_NotifyPre = "30min";
	}
	unless(defined($Events_DayNotify) and length($Events_DayNotify)) {
		$Events_DayNotify = 0;
	}
	# Print the config
	print CONFIG "# Day planner version $Version configuration file\n\n";
	print CONFIG "# - - -\n# User interface\n# - - -\n";
	print CONFIG "# If the EventEditor should expand the \"details\" by default\n#  1 = expand\n#  0 = don't expand\n";
	print CONFIG "EditorVerboseDefault=$EditorVerboseDefault\n";
	print CONFIG "\n# - - -\n# Normal events notification\n# - - -\n";
	print CONFIG "\n# If day planner should notify about an event ahead of time.\n#  0 = Don't notify\n";
	print CONFIG "#  10min = Notify 10 minutes ahead of time\n";
	print CONFIG "#  20min = Notify 20 minutes ahead of time\n";
	print CONFIG "#  30min = Notify 30 minutes ahead of time\n";
	print CONFIG "#  45min = Notify 45 minutes ahead of time\n";
	print CONFIG "#  1hr   = Notify 1 hour ahead of time\n";
	print CONFIG "#  2hrs  = Notify 2 hours ahead of time\n";
	print CONFIG "#  4hrs  = Notify 4 hours ahead of time\n";
	print CONFIG "#  6hrs  = Notify 6 hours ahead of time\n";
	print CONFIG "Events_NotifyPre=$Events_NotifyPre\n";
	print CONFIG "\n# If day planner should notify about an event one day before it occurs.\n#  0 - Don't notify one day in advance\n#  1 - Do notify one day in advance\n";
	print CONFIG "Events_DayNotify=$Events_DayNotify\n";
	# Close the config file
	close(CONFIG);
	# Tell the daemon to reload the config file
	if($DaemonInitialized) {
		unless(Daemon_DataSegment("RELOAD_CONFIG") eq "done\n") {
			# TODO: GUI dialog?
			DPIntWarn("Failed to tell the daemon to reload its configuration file. This might cause problems");
		}
	}
}

# Purpose: Load the configuration file
# Usage: LoadConfig(DIRECTORY, FILENAME);
sub LoadConfig ($$) {
	# The parameters
	my $Dir = $_[0];
	my $File = $_[1];
	# If it doesn't exist then we just let WriteConfig handle it
	unless (-e "$Dir/$File") {
		WriteConfig($Dir, $File);
		return(1);
	}
	
	# Open the config
	open(CONFIG, "<$Dir/$File") or do {
		DPError($Gettext->get(sprintf("Unable to read the configuration settings from %s: %s", "$Dir/$File", $!)));
		return(0);
	};
	
	# Load the config
	foreach(<CONFIG>) {
		next if m/^\s*#/;
		next unless m/=/;
		chomp;
		my $Option = $_;
		my $Value = $_;
		$Option =~ s/^\s*(.*)\s*=.*/$1/;
		$Value =~ s/^.*=\s*(.*)\s*/$1/;
		unless(defined($Value) and length($Value)) {
			DPIntWarn("Configuration setting \"$Option\" has an empty value");
		}
		# TODO: Perhaps these should be verified here?
		if ($Option eq 'EditorVerboseDefault') {
			$EditorVerboseDefault = $Value;
		} elsif ($Option eq 'Events_NotifyPre') {
			# NOTE: If this test is changed HERE it must be changed in dayplanner-daemon aswell
			unless ($Value =~ /^(\d+(min|hrs?){1}|0){1}$/) {
				DPIntWarn("Invalid value for $Option: \"$Value\" - setting to default \"30min\"");
				$Events_NotifyPre = '30min';
			} else {
				$Events_NotifyPre = $Value;
			}
		} elsif ($Option eq 'Events_DayNotify') {
			$Events_DayNotify = $Value;
		} elsif ($Option =~ /^ToolbarStyle$/) {
			DPIntWarn("Deprecated configuration setting \"$Option\" - ignored");
		} else {
			DPIntWarn("Unrecognized configuration setting \"$Option\", ignoring");
		}
	}
}

# Purpose: Load the default configuration file
# Usage: LoadDefaultConfig();
sub LoadDefaultConfig () {
	CreateSaveDir();
	return(LoadConfig($SaveToDir, $ConfigFile));
}

# Purpose: Save the default configuration file
# Usage: SaveDefaultConfig();
sub SaveDefaultConfig () {
	return(WriteConfig($SaveToDir, $ConfigFile));
}

# Purpose: Create the directory in $SaveToDir if it doesn't exist and display a error if it fails
# Usage: CreateSaveDir();
sub CreateSaveDir () {
	unless (-e $SaveToDir) {
		mkdir($SaveToDir) or do {
				DPError($Gettext->get(sprintf("Unable to create the directory %s: %s\nManually create this directory before closing this dialog.", $SaveToDir, $!)));
			}
	}
}

# Purpose: Save the datafile
# Usage: SaveDatafile(DIRECTORY, FILENAME, HashRef to save, Name of the hash);
sub SaveDatafile ($$$$) {
	# Create the progress window
	my $ProgressWin = Gtk2::Window->new();
	$ProgressWin->set_modal(1);
	$ProgressWin->set_transient_for($MainWindow);
	$ProgressWin->set_position('center-on-parent');
	$ProgressWin->set_title($Gettext->get("Saving..."));
	$ProgressWin->set_resizable(0);
	# Create the progress bar
	my $ProgressBar = Gtk2::ProgressBar->new();
	$ProgressBar->{activity_mode} = 0;
	$ProgressBar->set_fraction(0.0);
	# Add the bar to the window and show them
	$ProgressWin->add($ProgressBar);
	$ProgressBar->show();
	$ProgressWin->show();
	# We want the dumper to be pure (aka. make dumper output a proper syntax that is suitable for eval() or do())
	$Data::Dumper::Purity = 1;
	# Sort the keys
	$Data::Dumper::Sortkeys = 1;
	# Set the indentation
	$Data::Dumper::Indent = 1;
	# Pulse once
	$ProgressBar->pulse();
	# Create the save directory
	CreateSaveDir();
	# Pulse once
	$ProgressBar->pulse();
	# Open the savefile ($_[0]/$_[1]) for writing
	open(SAVEFILE, ">$_[0]/$_[1]") or do {
		# EMERGENCY FALLBACK
		
		# Okay, we couldn't open it. This is bad.
		# Now we try to detect a directory to fall back to.
		my $FallbackDirectory;
		my $Error = $!;
		my $FallbackFailed = 1;
		# Try to find a directory we can use
		foreach my $Fallback (@SaveFallbackDirs) {
			$ProgressBar->pulse();
			if (-e $Fallback and -w $Fallback) {
				if (-e "$Fallback/$_[1]" and ! -w "$Fallback/$_[1]") {
					next;
				}
				$FallbackDirectory = $Fallback;
				last;
			}
		}
		# Hide the progress window
		$ProgressWin->hide();
		# If $FallbackDirectory is true then display the error and try to open the fallback
		if ($FallbackDirectory) {
			DPError(sprintf($Gettext->get("FATAL ERROR: Unable to open %s for writing: %s\nWriting to %s instead"), "$_[0]/$_[1]", $Error, "$FallbackDirectory/$_[1]"));
			$FallbackFailed = 0;
			open(SAVEFILE, ">$FallbackDirectory/$_[1]") or $FallbackFailed = 1;
		} 
		# If FallbackDirectory failed or we didn't find one - output to STDOUT
		if ($FallbackFailed) {
			if ($FallbackDirectory) {	# If $FallbackDirectory was attempted but failed then display this
				DPError(sprintf($Gettext->get("FATAL ERROR: Unable to open %s for writing: %s\nWriting to %s instead"), "$FallbackDirectory/$_[1]", $Error, "STDOUT"));
			} else {			# If $FallbackDirectory wasn't possible, display this
				DPError(sprintf($Gettext->get("FATAL ERROR: Unable to open %s for writing: %s\nWriting to %s instead"), "$_[0]/$_[1]", $Error, "$FallbackDirectory/$_[1]"));
			}
			print STDOUT Dumper(\%CalendarContents);
			# By returning 0 we tell the caller that something went very wrong and that we
			# might not want to quit if that's what we're doing.
			return(0);
		}
		# Show the progress window again
		$ProgressWin->show();
	};
	# Print this
	print SAVEFILE "# Day Planner data file for day planner version $Version\n";
	print SAVEFILE "# Last saved on: ", scalar(localtime),"\n";
	print SAVEFILE "#\n# The format is explained in doc/SaveformatSyntax\n";
	# Pulse once
	$ProgressBar->pulse();
	# Dump the data
	print SAVEFILE Data::Dumper->Dump([$_[2]], ["*$_[3]"]);
	# Pulse once and close
	$ProgressBar->pulse();
	close(SAVEFILE);
	# Destroy the progress bar window
	$ProgressWin->destroy();
	# We successfully saved the data
	return(1);
}

# Purpose: Save the main data files
# Usage: SaveMainData();
sub SaveMainData () {
	my $Return = 'OKAY';
	unless(SaveDatafile($SaveToDir, $MainEventsFile, \%CalendarContents, "CalendarContents")) {
		$Return	= 'SAVE_FAILED';
	}
	unless(SaveDatafile($SaveToDir, $SpecialEventsFile, \%SpecialEvents, "SpecialEvents")) {
		$Return = 'SAVE_FAILED';
	}
	unless(SaveDatafile($SaveToDir, $BirthdayFile, \%BirthdayContents, "BirthdayContents")) {
		$Return = 'SAVE_FAILED';
	}
	# This to avoid unneccesary overhead in the daemon reloading files needlessly
	unless(Daemon_DataSegment("RELOAD_DATA") eq "done\n") {
		DPWarning($Gettext->get("<b><big>Day planner encountered an error while saving events</big></b>.\n\nThere appears to be another instance of day planner running. This may lead to data loss.\n\nLeaving this instance of Day Planner open while you resolve the issues with the other instance of Day Planner will ensure your data remains safe. Closing this instance of Day Planner before it can safely write recent changes will result in data loss."));
		if ($Return eq 'OKAY') {
			$Return = 'DAEMON_RELOAD_FAILURE';
		}
	}
	return($Return);
}

# Purpose: Save the data file and redraw the needed windows
# Usage: UpdatedData();
sub UpdatedData () {
	# Save the data
	SaveMainData();
	# Redraw the event list
	DrawEventlist();
	# Redraw the calendar
	CalendarChange();
}

# Purpose: Load the calendar contents
# Usage: LoadCalendar();
sub LoadCalendar () {
	if(DataLoadTest("$SaveToDir/$MainEventsFile")) {
		%CalendarContents = do("$SaveToDir/$MainEventsFile");
	}
	if(DataLoadTest("$SaveToDir/$BirthdayFile")) {
		%BirthdayContents = do("$SaveToDir/$BirthdayFile");
	}
	if(DataLoadTest("$SaveToDir/$SpecialEventsFile")) {
		%SpecialEvents = do("$SaveToDir/$SpecialEventsFile");
	}
	if(DataLoadTest("$SaveToDir/$AllDayEventsFile")) {
		%AllDayEvents = do("$SaveToDir/$AllDayEventsFile");
	}
	return(1);
}

# Purpose: Test if a load can be successfully performed of the supplied file
# Usage: DataLoadTest("/path/to/file");
sub DataLoadTest () {
	# If the calendar savefile exists
	if (-e "$_[0]") {
		# If it isn't readable then we warn and return
		unless (-r "$_[0]") {
			DPIntWarn("Unable to read the calendar at $_[0]: It isn't readable by me");
			return(0);
		}
		# If it isn't writeable then we just warn (the file can still be loaded)
		unless (-w "$_[0]") {
			DPIntWarn("Unable to write the calendar at $_[0]: It isn't writeable by me. Expect trouble!");
		}
		return(1);
	} else {
		# If the file doesn't exist then we just assume that it isn't created yet,
		# so we return false, but do it silently.
		return(0);
	}
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Core helper functions
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Purpose: Print a warning to STDERR with proper output
# Usage: DPIntWarn("Warning");
sub DPIntWarn ($) {
	warn "*** (Day Planner $Version) Warning: $_[0]\n";
}

# Purpose: Delete keys from %CalendarContents, recusively if needed
# Usage: CalendarDelete(year,month,day,time);
sub CalendarDelete ($$$$) {
	my ($EventYear,$EventMonth,$EventDay,$EventTime) = @_;
	delete($CalendarContents{$EventYear}{$EventMonth}{$EventDay}{$EventTime});
		unless (keys(%{$CalendarContents{$EventYear}{$EventMonth}{$EventDay}})) {
			delete($CalendarContents{$EventYear}{$EventMonth}{$EventDay});
				unless (keys(%{$CalendarContents{$EventYear}{$EventMonth}})) {
					delete($CalendarContents{$EventYear}{$EventMonth});
						unless(keys(%{$CalendarContents{$EventYear}})) {
							delete($CalendarContents{$EventYear});
						}
			}
	}
}

# Purpose: Delete keys from %BirthdayContents, recusively if needed
# Usage: BirthdayDelete(month,day,name);
sub BirthdayDelete ($$$) {
	my ($EventMonth,$EventDay,$Name) = @_;
	delete($BirthdayContents{$EventMonth}{$EventDay}{$Name});
		unless (keys(%{$BirthdayContents{$EventMonth}{$EventDay}})) {
			delete($BirthdayContents{$EventMonth}{$EventDay});
				unless (keys(%{$BirthdayContents{$EventMonth}})) {
					delete($BirthdayContents{$EventMonth});
			}
	}
}

# Purpose: Print formatted --help output
# Usage: PrintHelp("-shortoption", "--longoption", "description");
sub PrintHelp($$$) {
	printf "%-4s %-16s %s\n", "$_[0]", "$_[1]", "$_[2]";
}

# Purpose: Recursively test for defined data in %CalendarContents
# 		If a single test is run then invalid data might get inserted into %CalendarContents
# 		this avoids that by doing a recursive test
# Usage: CalendarDefined(year,month,day,time);
sub CalendarDefined ($$$$) {
	my ($EventYear,$EventMonth,$EventDay,$EventTime,$EventType) = @_;
	if(defined($CalendarContents{$EventYear}) and defined($CalendarContents{$EventYear}{$EventMonth}) and defined($CalendarContents{$EventYear}{$EventMonth}{$EventDay}) and defined($CalendarContents{$EventYear}{$EventMonth}{$EventDay}{$EventTime})) {
			return(1)
		}
	return(0);
}

# Purpose: Recursively test for defined data in %BirthdayContents
# 		If a single test is run then invalid data might get inserted into %BirthdayContents
# 		this avoids that by doing a recursive test
# Usage: BirthdayDefined(month,day,summary);
sub BirthdayDefined ($$$) {
	my ($EventMonth, $EventDay, $EventSummary) = @_;
	if(defined($BirthdayContents{$EventMonth}) and defined($BirthdayContents{$EventMonth}{$EventDay}) and defined($BirthdayContents{$EventMonth}{$EventDay}{$EventSummary})) {
			return(1)
		}
	return(0);
}

# Purpose: Handle various signals gracefully
# Usage: $SIG{SIGNAL} = \&DP_SigHandler;
sub DP_SigHandler {
	$| = 1;
	print "SIG$_[0] recieved.\nSaving data...";
	if(SaveMainData() eq "SAVE_FAILED") {
		print "FAILED";
	} else {
		print "done";
	}
	print "\nWriting state file...";
	WriteStateFile($SaveToDir, "state.conf");
	print "done\nExiting the gtk2 main loop...";
	Gtk2->main_quit;
	print "done\nClosing the daemon connection...";
	CloseDaemon();
	print "done\nExiting\n";
	exit(0);
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# GUI helper functions
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Purpose: Detect the path to the image file(s) supplied. Returns the path to the
# 		first one found or undef
# Usage: $Image = DetectImage(image1, image2);
sub DetectImage {
	my $I_Am_At = dirname(Cwd::realpath($0));
	foreach my $Image (@_) {
		foreach my $Dir ("$I_Am_At/art", $I_Am_At, "/usr/share/dayplanner", "/usr/local/dayplanner", "/usr/local/share/dayplanner", "/usr/share/dayplanner/art", "/usr/local/dayplanner/art", "/usr/local/share/dayplanner/art", "/usr/share/icons/large", "/usr/share/icons", "/usr/share/icons/mini") {
			if (-e "$Dir/$Image") {
				return("$Dir/$Image");
			}
		}
	}
	return(undef);
}

# Purpose: Delete the event currently selected in the eventlist
# Usage: DeleteEvent();
#  (calls CalendarDelete with the correct parameters)
sub DeleteEvent () {
	my $Selected = [$EventlistWidget->get_selected_indices]->[0];
	# Unless $Selected is defined we don't have anything selected in the eventlist
	unless(defined($Selected)) {
		return(0);
	}
	my $Type = GetEventListType();
	my ($EventYear, $EventMonth, $EventDay) = $CalendarWidget->get_date();$EventMonth++;
	my $EventTime = $EventlistWidget->{data}[$Selected][0];
	my $EventSummary = $EventlistWidget->{data}[$Selected][1];

	if($Type eq 'normal') {
		if (defined($EventTime)) {
			CalendarDelete($EventYear,$EventMonth,$EventDay,$EventTime);
			DrawEventlist();
			CalendarChange();
			SaveMainData();
		}
	} elsif ($Type eq 'bday') {
		if (defined($EventSummary)) {
			BirthdayDelete($EventMonth, $EventDay, GetRealBirthdayName($EventSummary));
			DrawEventlist();
			CalendarChange();
			SaveMainData();
		}
	} else {
		DPIntWarn("DeleteEvent: Attempted to handle unsupported \$Type: $Type");
	}
}

# Purpose: Get the real name of the person whose birthday it is
# Usage: my $Name = GetRealBirthdayName(NAME);
sub GetRealBirthdayName ($) {
	my $Name = $_[0];
	my $BirthdayString = $Gettext->get("%s's birthday");
	$BirthdayString =~ s/%s//;
	$Name =~ s/$BirthdayString$//;
	return($Name);
}

# Purpose: Detect which kind of event is selected in the eventlist
# Usage: my $Type = GetEventListType();
sub GetEventListType() {
	my $Selected = [$EventlistWidget->get_selected_indices]->[0];
	# If $Selected isn't defined then nothing *is* selected and thus we just return (false)
	unless(defined($Selected)) {
		return(0);
	}
	# Initialize
	my $Time = $EventlistWidget->{data}[$Selected][0];
	my $Summary = $EventlistWidget->{data}[$Selected][1];
        my ($EventYear, $EventMonth, $EventDay) = $CalendarWidget->get_date();$EventMonth++;

	# Detect the event type
	if (defined($Time) and length($Time)) {
		return('normal');
	} elsif (defined($Summary) and length($Summary)) {
		return('bday')
	} else {
		return(0);
		DPIntWarn("FATAL: GetEventListType: Unable to get the type of the selected event ($EventYear-$EventMonth-$EventDay-$Time/$Summary");
	}
}

# Purpose: Close a window when the escape key is pressed
# Usage: $WIDGET->signal_connect("key_release_event" => \&EscapeKeyHandler);
sub EscapeKeyHandler () {
	my ($widget, $event) = @_;
	if ($event->keyval == $Gtk2::Gdk::Keysyms{Escape}) {
		$widget->destroy();
	}
}

# Purpose: Display an error dialog
# Usage: DPError("Error message");
sub DPError ($) {
	my $Dialog = Gtk2::MessageDialog->new($MainWindow, "modal", 'error', 'ok', "$_[0]");
	$Dialog->run();
	$Dialog->destroy();
}

# Purpose: Display a warning dialog
# Usage: DPWarning("Warning");
sub DPWarning ($) {
	my $Dialog = Gtk2::MessageDialog->new_with_markup($MainWindow, "modal", 'warning', 'ok', "$_[0]");
	$Dialog->run();
	$Dialog->destroy();
}

# Purpose: Display an information dialog
# Usage: DPInfo("Information message");
sub DPInfo ($) {
	my $Dialog = Gtk2::MessageDialog->new($MainWindow, "modal", 'info', 'ok', "$_[0]");
	$Dialog->run();
	$Dialog->destroy();
}

# Purpose: Display a question dialog
# Usage: DPQuestion("Question");
# 	Returns true on yes, false on anything else
sub DPQuestion ($) {
	my $Dialog = Gtk2::MessageDialog->new(undef, "modal", 'question', 'yes-no', $_[0]);
	my $Reply = $Dialog->run();
	$Dialog->destroy();
	if ($Reply eq 'yes') {
		return(1);
	} else {
		return(0);
	}
}

# Purpose: Call save functions on exit
# Usage: QuitSub();
sub QuitSub () {
	$MainWindow->hide();
	my $SaveData = SaveMainData();
	if ($SaveData eq 'SAVE_FAILED') {
		unless(DPQuestion($Gettext->get("Some files could not be saved correctly. Are you sure you want to quit?"))) {
			$MainWindow->show();
			return(1);
		}
	} elsif ($SaveData eq 'DAEMON_RELOAD_FAILURE') {
		unless(DPQuestion($Gettext->get("Are you sure you still want to quit?"))) {
			$MainWindow->show();
			return(1);
		}
	}
	
	WriteStateFile($SaveToDir, "state.conf");
	
	Gtk2->main_quit;
	CloseDaemon();
	exit(0);
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# GUI calendar functions
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Purpose: Sets the active calendar items in the $CalendarWidget
# Usage: SetActiveCalItems(YEAR, NUMERICAL_MONTH[1-12]);
sub SetActiveCalItems ($$) {
	$CalendarWidget->clear_marks;			# Clear the current marks
	# Calendar contents
	if (defined($CalendarContents{$_[0]}) and defined($CalendarContents{$_[0]}{$_[1]})) {
		foreach my $Day (keys %{$CalendarContents{$_[0]}{$_[1]}}) {
			$CalendarWidget->mark_day($Day);	# Mark this day
		}
	}
	# Birthdays
	if (defined($BirthdayContents{$_[1]})) {
		foreach my $Day (keys %{$BirthdayContents{$_[1]}}) {
			$CalendarWidget->mark_day($Day);	# Mark this day
		}
	}
}

# Purpose: Sets the date/time variables to the current date/time
# Usage: GetDate();
sub GetDate () {
	($currsec,$currmin,$currhour,$currmday,$currmonth,$curryear,$currwday,$curryday,$currisdst) = localtime(time);
	$curryear += 1900;						# Fix the year format
	$currmonth++;							# Fix the month format
}

# Purpose: Calls SetActiveCalItems on the current year/month displayed in the $CalendarWidget
# Usage: CalendarChange();
sub CalendarChange () {
	my $Month = $CalendarWidget->month;
	$Month++;
	SetActiveCalItems($CalendarWidget->year, $Month);
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# GUI event adding functions
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Purpose: Get a properly formatted event time from two widgets (min/hour)
# Usage: my $Time = GetTimeFromWidgets($HourSpinner, $MinuteSpinner);
sub GetTimeFromWidgets ($$) {
	# In the future this sub will take a third argument, which is either an AM/PM
	# selection box, or undef - so that seamless AM/PM support is needed.
	
	my ($HourSpinner, $MinuteSpinner) = @_;	
	my $Hour = $HourSpinner->get_value_as_int();
	my $Minute = $MinuteSpinner->get_value_as_int();
	if ($Hour <= 9) {
		$Hour = "0$Hour";
	}
	if ($Minute <= 9) {
		$Minute = "0$Minute";
	}
	return("$Hour:$Minute");
}

# Purpose: Create the widgets for selecting the time
# Usage: my ($HourSpinner, $MinuteSpinner, $TimeHBox) = TimeSelection("HH:MM");
sub TimeSelection ($) {
	my $Time = $_[0];
	# The hour adjustment
	my $HourAdjustment = Gtk2::Adjustment->new(0.0, 0.0, 23.0, 1.0, 5.0, 0.0);
	# The minute adjustment
	my $MinuteAdjustment = Gtk2::Adjustment->new(0.0, 0.0, 59.0, 1.0, 5.0, 0.0);
	
	# Create the spinners
	my $HourSpinner = Gtk2::SpinButton->new($HourAdjustment, 0, 0);
	my $MinuteSpinner = Gtk2::SpinButton->new($MinuteAdjustment, 0, 0);
	# Show them
	$HourSpinner->show();
	$MinuteSpinner->show();
	
	# Create a simple seperating label
	my $TimeSeperatorLabel = Gtk2::Label->new(' : ');
	$TimeSeperatorLabel->show();
	
	# Make them activate the default action
	$HourSpinner->set_activates_default(1);
	$MinuteSpinner->set_activates_default(1);
	
	# Get the time
	my $HSTime = $Time;		# Hour
	my $MSTime = $Time;		# Minute
	$HSTime =~ s/^(\d+):\d+$/$1/;
	$MSTime =~ s/^\d+:(\d+)$/$1/;
	# Set the initial value
	$HourSpinner->set_value($HSTime);
	$MinuteSpinner->set_value($MSTime);
	
	# Create a HBox and pack them onto it
	my $TimeSpinnerHBox = Gtk2::HBox->new(0,0);
	$TimeSpinnerHBox->pack_start($HourSpinner,0,0,0);
	$TimeSpinnerHBox->pack_start($TimeSeperatorLabel,0,0,0);
	$TimeSpinnerHBox->pack_start($MinuteSpinner,0,0,0);
	$TimeSpinnerHBox->show();

	# Return the widgets
	return($HourSpinner, $MinuteSpinner, $TimeSpinnerHBox);
}

# Purpose: Create the window that will contain the event editor
# Usage: my ($Window, $VBox_HBoxContainer, $OKButton, $CancelButton) = CreateEventContainerWin(TITLE, LABEL, OK_BUTTON_TYPE);
#
# TITLE is the title of the window, LABEL is the label to display on top of the window.
# OK_BUTTON_TYPE is the Gtk2::Stock ID to use for the button
sub CreateEventContainerWin ($$$) {
	# Get the options passed to the sub
	my ($WindowTitle, $EventLabel, $OkButtonType) = @_;
	
	# Get the date
	my ($EventYear, $EventMonth, $EventDay) = $CalendarWidget->get_date();$EventMonth++;

	# ==================================================================
	# BUILD THE WINDOW
	# ==================================================================
	my $AddEventBox = Gtk2::Window->new();
	$AddEventBox->set_modal(1);
	$AddEventBox->set_transient_for($MainWindow);
	$AddEventBox->set_position('center-on-parent');
	$AddEventBox->set_title($WindowTitle);
	$AddEventBox->set_resizable(0);
	$AddEventBox->set_border_width(5);
	$AddEventBox->set_skip_taskbar_hint(1);
	$AddEventBox->set_skip_pager_hint(1);

	# Handle closing
	$AddEventBox->signal_connect("destroy" => sub { $AddEventBox->destroy; $MainWindow->set_sensitive(1) });
	$AddEventBox->signal_connect("delete-event" => sub { $AddEventBox->destroy; $MainWindow->set_sensitive(1) });
	
	# Primary vbox
	my $ADPrimVBox = Gtk2::VBox->new();
	$AddEventBox->add($ADPrimVBox);
	$ADPrimVBox->show();
	
	# Add the label with the name
	my $DateLabel = Gtk2::Label->new(sprintf($EventLabel,$EventDay, $MonthNames{$EventMonth},$EventYear));
	$DateLabel->show();
	$ADPrimVBox->pack_start($DateLabel,1,0,0);
	
	# The HBox for the frame
	my $FrameHBox = Gtk2::HBox->new();
	$FrameHBox->show();
	$ADPrimVBox->pack_start($FrameHBox,1,1,0);
	
	# Create the frame
	my $TBFrame = Gtk2::Frame->new();
	$TBFrame->set_label($Gettext->get("Event"));
	$FrameHBox->pack_start($TBFrame,1,1,0);
	$TBFrame->show();
	
	# TODO: Add a pop-up where you can select the date (DatePopup())
	
	# Create the vbox for use in the frame
	my $TBVBox = Gtk2::VBox->new();
	$TBFrame->add($TBVBox);
	$TBVBox->show();
	
	# ==================================================================
	# Call the functions that constructs the main window contents
	# ==================================================================
	
	# Create the hbox for the buttons
	my $TB_ButtonHBox = Gtk2::HBox->new(0,6);
	$TB_ButtonHBox->show();
	$ADPrimVBox->pack_end($TB_ButtonHBox,0,0,0);
	
	# Create the OK button
	my $OKButton = Gtk2::Button->new_from_stock($OkButtonType);
	$OKButton->show();
	$TB_ButtonHBox->pack_end($OKButton,0,0,0);
	$OKButton->can_default(1);

	# Create the cancel button
	my $CancelButton = Gtk2::Button->new_from_stock('gtk-cancel');
	$CancelButton->signal_connect("clicked" => sub { $AddEventBox->destroy;
		});
	$CancelButton->show();
	$TB_ButtonHBox->pack_end($CancelButton,0,0,0);
	
	# Handle the esc button
	$AddEventBox->signal_connect("key_release_event" => \&EscapeKeyHandler);
	$AddEventBox->set_default($OKButton);

	# Return the widgets
	return($AddEventBox, $TBVBox, $OKButton, $CancelButton);
}

# Purpose: Add a event. Creates the main window and calls the proper event functions
# Usage: AddEvent();
sub AddEvent () {
	$MainWindow->set_sensitive(0);
        my ($EventYear, $EventMonth, $EventDay) = $CalendarWidget->get_date();$EventMonth++;
	my $OKSignal;
	my %TimeHash = (
		EventYear => $EventYear,
		EventMonth => $EventMonth,
		EventDay => $EventDay,
	);
		
	# Create the main window with the appropriate OK/Cancel buttons and the event frame
	my ($Window, $VBox_HBoxContainer, $OKButton, $CancelButton) = CreateEventContainerWin($Gettext->get("Add an event"), $Gettext->get('Adding an event on the %s. %s %s'), 'gtk-add');
	# HBox
	my $SelectorHBox = Gtk2::HBox->new();
	$VBox_HBoxContainer->pack_start($SelectorHBox,0,0,0);
	$SelectorHBox->show();
	# Label
	my $EventTypeLabel = Gtk2::Label->new($Gettext->get("Event type:"));
	$SelectorHBox->pack_start($EventTypeLabel,0,0,0);
	$EventTypeLabel->show();
	# Combo selector
	my $EventType_Combo = Gtk2::ComboBox->new_text;
	$EventType_Combo->insert_text(0, $Gettext->get("Normal"));
	$EventType_Combo->insert_text(1, $Gettext->get("Birthday"));
	$SelectorHBox->pack_start($EventType_Combo,0,0,0);
	$EventType_Combo->show();

	# Create the tooltips widget
	my $Tooltips = Gtk2::Tooltips->new();
	$Tooltips->enable();
	# Set the tooltips
	$Tooltips->set_tip($OKButton, $Gettext->get("Add this event"));
	$Tooltips->set_tip($CancelButton, $Gettext->get("Discard this event"));
	
	# Create the widgets for the normal event selection
	my ($NE_MainWidget, $NE_HourSpinner, $NE_MinuteSpinner, $NE_SummaryWidget, $NE_DetailsWidget) = NormalEventWindow("NULL", $OKButton, $VBox_HBoxContainer, $Window);
	# Create the widgets for the birthday event selection
	my ($BE_MainWidget, $BE_NameWidget) = BirthdayEventWindow(undef, $VBox_HBoxContainer, $Window);

	# Handle changed values in the combo box
	$EventType_Combo->signal_connect('changed' => sub {
			my $ActiveIndex = $EventType_Combo->get_active;
			if ($ActiveIndex == 0) {
				$BE_MainWidget->hide();
				$NE_MainWidget->show();
				$OKButton->signal_handler_disconnect($OKSignal) if defined($OKSignal);
				$OKSignal = $OKButton->signal_connect('clicked' => sub {
					NormalEvent_OK($Window, $NE_HourSpinner, $NE_MinuteSpinner, $NE_SummaryWidget, $NE_DetailsWidget, \%TimeHash, 0);
				});
			} elsif ($ActiveIndex == 1) {
				$NE_MainWidget->hide();
				$BE_MainWidget->show();
				$OKButton->signal_handler_disconnect($OKSignal) if defined($OKSignal);
				$OKSignal = $OKButton->signal_connect('clicked' => sub {
					BirthdayEvent_OK($Window, $BE_NameWidget, \%TimeHash, 0)});
			}
		});

	$EventType_Combo->set_active(0);
	
	# Show the window
	$Window->show();
}

# Purpose: Edit the event currently selected in the eventlist
# Usage: EditEvent ();
sub EditEvent () {
	my $Selected = [$EventlistWidget->get_selected_indices]->[0];
	# If $Selected isn't defined then nothing *is* selected and thus we just return (false)
	unless(defined($Selected)) {
		return(0);
	}
	
	$MainWindow->set_sensitive(0);

	# Initialize
	my $Time = $EventlistWidget->{data}[$Selected][0];
	my $Summary = $EventlistWidget->{data}[$Selected][1];
	my $Tooltips = Gtk2::Tooltips->new();
	$Tooltips->enable();
        my ($EventYear, $EventMonth, $EventDay) = $CalendarWidget->get_date();$EventMonth++;
	my %TimeHash = (
		EventYear => $EventYear,
		EventMonth => $EventMonth,
		EventDay => $EventDay,
		OldEventYear => $EventYear,
		OldEventMonth => $EventMonth,
		OldEventDay => $EventDay,
		OldEventTime => $Time,
	);
		
	# Create the main window with the appropriate OK/Cancel buttons and the event frame
	my ($Window, $VBox_HBoxContainer, $OKButton, $CancelButton);

	my $Type = GetEventListType();

	if ($Type eq 'normal') {
		# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		# NORMAL EVENT
		# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		
		if(CalendarDefined($EventYear,$EventMonth,$EventDay,$Time)) {
			($Window, $VBox_HBoxContainer, $OKButton, $CancelButton) = CreateEventContainerWin($Gettext->get("Editing an event"), $Gettext->get('Editing an event on the %s. %s %s'), 'gtk-ok');

			# Create the widgets for the normal event selection
			my ($NE_MainWidget, $NE_HourSpinner, $NE_MinuteSpinner, $NE_SummaryWidget, $NE_DetailsWidget) = NormalEventWindow($Time, $OKButton, $VBox_HBoxContainer, $Window);
	
			$OKButton->signal_connect('clicked' => sub {
					NormalEvent_OK($Window, $NE_HourSpinner, $NE_MinuteSpinner, $NE_SummaryWidget, $NE_DetailsWidget, \%TimeHash, 1);
			});
		
			# Show the default widget (Normal event)
			$NE_MainWidget->show();
		} else {
			DPIntWarn("BUG!: EditEvent: Unable to edit $Type event: $EventYear/$EventMonth/$EventDay/$Time. Please report this");
			$MainWindow->set_sensitive(1);
			return(0);
		}
	} elsif ($Type eq 'bday') {
		# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		# BIRTHDAY EVENT
		# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
		($Window, $VBox_HBoxContainer, $OKButton, $CancelButton) = CreateEventContainerWin($Gettext->get("Editing a birthday"), $Gettext->get('Editing a birthday on the %s. %s %s'), 'gtk-ok');
		
		$Summary = GetRealBirthdayName($Summary);
		$TimeHash{OldEventSummary} = $Summary;
		if(BirthdayDefined($EventMonth, $EventDay, $Summary)) {
			# Create the widgets for the birthday event selection
			my ($BE_MainWidget, $BE_NameWidget) = BirthdayEventWindow($Summary, $VBox_HBoxContainer, $Window);
			$BE_MainWidget->show();
			$OKButton->signal_connect('clicked' => sub { BirthdayEvent_OK ($Window, $BE_NameWidget, \%TimeHash, 1)});
		} else {
			DPIntWarn("BUG!: EditEvent: Unable to edit $Type event: $EventMonth/$EventDay/$Summary. Please report this");
			$MainWindow->set_sensitive(1);
			return(0);
		}
			
	} else {
		DPIntWarn("BUG!: EditEvent: \$Type contained invalid value: $Type");
		$MainWindow->set_sensitive(1);
		return(0);
	}
	
	$Tooltips->set_tip($CancelButton, $Gettext->get("Discard changes"));
	$Tooltips->set_tip($OKButton, $Gettext->get("Accept changes"));
			
	# Show the window
	$Window->show();
}

# Purpose: Create the widgets for editing a normal(events.dpd) event (%CalendarContents)
# Usage: my ($NormalEventWidget, $HourSpinner, $MinuteSpinner, $SummaryWidget, $DetailsWidget) = NormalEventWindow(TIME, OK_BUTTON, VBOX_WIDGET, MAIN_WINDOW_WIDGET);
#
# TIME is the time you're editing or undef
# OK_BUTTON is the OK button widget to attach to
# VBOX_WIDGET is the widget you want to pack our table into
# MAIN_WINDOW_WIDGET is the main window it will live inside
sub NormalEventWindow ($$$$) {
	# ==================================================================
	# INITIALIZE
	# ==================================================================
	my ($EventTime, $OKButton, $ParentVBox, $MyWindow) = @_;

	my $IsEditing = 0;
	
	my ($EventYear, $EventMonth, $EventDay) = $CalendarWidget->get_date();$EventMonth++;
	my ($EventSummary, $EventFulltext);
	my ($OldEventYear, $OldEventMonth,$OldEventDay,$OldEventTime);
	
	# Check if the event is already defined, if it is then we assume that we're editing
	if(CalendarDefined($EventYear,$EventMonth,$EventDay,$EventTime)) {
		# We assume these two aren't empty. This will need to change if another part becomes obligatory
		$EventSummary = $CalendarContents{$EventYear}{$EventMonth}{$EventDay}{$EventTime}{"summary"};
		$EventFulltext = $CalendarContents{$EventYear}{$EventMonth}{$EventDay}{$EventTime}{"fulltext"};
		($OldEventYear, $OldEventMonth,$OldEventDay,$OldEventTime) = ($EventYear,$EventMonth,$EventDay,$EventTime);
		$IsEditing = 1;
	}

	if ($EventTime eq 'NULL') {
		$EventTime = "00:00";
	}

	# Create the tooltips widget
	my $Tooltips = Gtk2::Tooltips->new();
	$Tooltips->enable();
	
	# Create our main vbox
	my $MainVBox = Gtk2::VBox->new();
	$ParentVBox->pack_start($MainVBox,0,0,0);
	
	# Create the table inside the frame
	my $ContentTable = Gtk2::Table->new(2,2);
	$ContentTable->show();
	$MainVBox->pack_start($ContentTable,1,1,0);
	
	# ==================================================================
	# ADD THE TIME/SUMMARY BOXES
	# ==================================================================
	
	# Create the time label
	my $TimeLabel = Gtk2::Label->new($Gettext->get('Time:'));
	$TimeLabel->show();
	$ContentTable->attach_defaults($TimeLabel, 0,1,0,1);
	
	# Time entry box
	my ($HourSpinner, $MinuteSpinner, $TimeHBox) = TimeSelection($EventTime);
	# Attach them to our main widget
	$ContentTable->attach_defaults($TimeHBox, 1,2,0,1);
	
	# Create the summary label
	my $SummaryLabel = Gtk2::Label->new($Gettext->get('Summary:'));
	$SummaryLabel->show();
	$ContentTable->attach_defaults($SummaryLabel, 0,1,1,2);

	# Create the summary entry box
	my $SummaryEntry = Gtk2::Entry->new();
	if (defined($EventSummary) and length($EventSummary)) {
		$SummaryEntry->set_text($EventSummary);
	}
	$SummaryEntry->set_activates_default(1);
	$SummaryEntry->show();
	$ContentTable->attach_defaults($SummaryEntry, 1,2,1,2);
	$Tooltips->set_tip($SummaryEntry, $Gettext->get("Enter a summary of the event here"));
	
	# ==================================================================
	# ADD THE EXTENDED ENTRY
	# ==================================================================
	my $FulltextWindow;
	
	my $FT_Expander = Gtk2::Expander->new($Gettext->get("Details"));
	$MainVBox->pack_start($FT_Expander,0,0,0);
	$FT_Expander->show();
	if ($EditorVerboseDefault) {
		$FT_Expander->set_expanded(1);
	}
	$Tooltips->set_tip($FT_Expander, $Gettext->get("Use this if you need to enter additional information about the event"));
	
	# Add the extended entry box
	my $FulltextEntry = Gtk2::TextView->new();
	$FulltextEntry->set_editable(1);
	$FulltextEntry->set_wrap_mode("word-char");
	$FulltextEntry->show();
	# Add text to it if needed
	if (defined($EventFulltext) and $EventFulltext =~ /\S/) {
		my $AddEventBuffer = Gtk2::TextBuffer->new();
		$AddEventBuffer->set_text($EventFulltext);
		$FulltextEntry->set_buffer($AddEventBuffer);
		$FT_Expander->set_expanded(1);
	}

	$FulltextWindow = Gtk2::ScrolledWindow->new;
	$FulltextWindow->set_policy('automatic', 'automatic');
	$FulltextWindow->add($FulltextEntry);
	$FulltextWindow->show();
	$FT_Expander->add($FulltextWindow);
	
	return($MainVBox, $HourSpinner, $MinuteSpinner, $SummaryEntry, $FulltextEntry);
}

# Purpose: Create the widgets for editing a birthday(birthdays.dpd) event (%BirthdayContents)
# Usage: my ($BirthdayEventWidget, $SummaryWidget) = NormalEventWindow(SUMMARY, VBOX_WIDGET, MAIN_WINDOW_WIDGET);
#
# SUMMARY is the birthday you're editing or undef
# VBOX_WIDGET is the widget you want to pack our widgets into
# MAIN_WINDOW_WIDGET is the main window it will live inside
sub BirthdayEventWindow ($$$) {
	# ==================================================================
	# INITIALIZE
	# ==================================================================
	my ($EventSummary, $ParentVBox, $MyWindow) = @_;

	my $IsEditing = 0;
	
	my ($EventYear, $EventMonth, $EventDay) = $CalendarWidget->get_date();$EventMonth++;
	my ($OldEventMonth,$OldEventDay,$OldEventSummary);
	
	# Check if the event is already defined, if it is then we assume that we're editing
	if(defined($EventSummary) and length($EventSummary)) {
		($OldEventMonth,$OldEventDay,$OldEventSummary) = ($EventMonth,$EventDay,$EventSummary);
		$IsEditing = 1;
	}
	
	# Create our main vbox
	my $MainVBox = Gtk2::VBox->new();
	$ParentVBox->pack_start($MainVBox,0,0,0);
	
	# Create the tooltips widget
	my $Tooltips = Gtk2::Tooltips->new();
	$Tooltips->enable();
	
	# Create the table inside the frame
	my $ContentTable = Gtk2::Table->new(2,2);
	$ContentTable->show();
	$MainVBox->pack_start($ContentTable,1,1,0);
	
	# ==================================================================
	# ADD THE TIME/SUMMARY BOXES
	# ==================================================================
	
	# Create the summary label
	my $SummaryLabel = Gtk2::Label->new($Gettext->get('Name:'));
	$SummaryLabel->show();
	$ContentTable->attach_defaults($SummaryLabel, 0,1,1,2);

	# Create the summary entry box
	my $SummaryEntry = Gtk2::Entry->new();
	if (defined($EventSummary) and length($EventSummary)) {
		$SummaryEntry->set_text($EventSummary);
	}
	$SummaryEntry->set_activates_default(1);
	$SummaryEntry->show();
	$ContentTable->attach_defaults($SummaryEntry, 1,2,1,2);
	$Tooltips->set_tip($SummaryEntry, $Gettext->get("Enter the name of the person whose birthday it is here"));
	
	return($MainVBox, $SummaryEntry);
}

# Purpose: Handle the OK button for the Normal event widget
# Usage: $OKButton->signal_connect('clicked' => sub { NormalEvent_OK($MainWindow, $HourSpinner, $MinuteSpinner, $SummaryEntry, $FulltextEntry, \%TimeHash, IS_EDITING)});
#
# IS_EDITING is either true or false, false when it's a new one being added, true when it's an
# old one being edited
sub NormalEvent_OK ($$$$$$$) {
	my ($MyWindow, $HourSpinner, $MinuteSpinner, $SummaryEntry, $FulltextEntry, $TimeHash, $IsEditing) = @_;
	my $Error = 0;
	
	# Get the contents
	my $Time = GetTimeFromWidgets($HourSpinner,$MinuteSpinner);
	my $Summary = $SummaryEntry->get_text;
	my $FulltextBuff = $FulltextEntry->get_buffer;
	my $Fulltext = $FulltextBuff->get_text($FulltextBuff->get_bounds,1);

	# Get variables from the TimeHash
	my $EventYear = ${$TimeHash}{EventYear};
	my $EventMonth = ${$TimeHash}{EventMonth};
	my $EventDay = ${$TimeHash}{EventDay};
	my $OldEventYear = ${$TimeHash}{OldEventYear};
	my $OldEventMonth = ${$TimeHash}{OldEventMonth};
	my $OldEventDay = ${$TimeHash}{OldEventDay};
	my $OldEventTime = ${$TimeHash}{OldEventTime};
	
	# Make sure it's not a dupe (that would end up overwriting data)
	if ($IsEditing) {
		if (defined($CalendarContents{$EventYear}{$EventMonth}{$EventDay}{$Time})) {
			unless ($EventYear eq $OldEventYear and $EventMonth eq $OldEventMonth  and $EventDay eq $OldEventDay and $Time eq $OldEventTime) {
				DPError(sprintf($Gettext->get("There is already an event at %s on %s %s. Please select another time for this event."), $Time, $EventDay, $MonthNames{$EventMonth}));
				$Error = 1;
			}
		}
	} else {
		if (defined($CalendarContents{$EventYear}{$EventMonth}{$EventDay}{$Time})) {
				DPError(sprintf($Gettext->get("There is already an event at %s on %s %s. Please select another time for this event."), $Time, $EventDay, $MonthNames{$EventMonth}));
				$Error = 1;
			}
	}
	unless ($Summary) {
		DPError($Gettext->get("There is no summary for this event. Please enter a summary."));
		$Error = 1;
	}
	# We don't do this if an error occurred
	unless ($Error) {
		# Delete old hash if needed
		if($IsEditing) {
			CalendarDelete($OldEventYear,$OldEventMonth,$OldEventDay,$OldEventTime);
		}
		# Add them to the hash
		$CalendarContents{$EventYear}{$EventMonth}{$EventDay}{$Time}{'summary'} = $Summary;
		$CalendarContents{$EventYear}{$EventMonth}{$EventDay}{$Time}{'fulltext'} = $Fulltext;
		# Call UpdatedData to tell Day planner to save the data and redraw widgets
		UpdatedData();
		# Destroy our window, it will get the signal and do anything it needs to
		$MyWindow->destroy;
		$MainWindow->set_sensitive(1);
	}
}

# Purpose: Handle the OK button for the birthday event widget
# Usage: $OKButton->signal_connect('clicked' => sub { BirthdayEvent_OK ($MainWindow, $SummaryEntry, \%TimeHash, IS_EDITING)});
#
# IS_EDITING is either true or false, false when it's a new one being added, true when it's an
# old one being edited
sub BirthdayEvent_OK ($$$$) {
	my ($MyWindow, $SummaryEntry, $TimeHash, $IsEditing) = @_;
	my $Error = 0;
	
	# Get the contents
	my $Summary = $SummaryEntry->get_text;

	# Get variables from the TimeHash
	my $EventMonth = ${$TimeHash}{EventMonth};
	my $EventDay = ${$TimeHash}{EventDay};
	my $OldEventMonth = ${$TimeHash}{OldEventMonth};
	my $OldEventDay = ${$TimeHash}{OldEventDay};
	my $OldEventSummary = ${$TimeHash}{OldEventSummary};
	
	# Make sure it's not a dupe (that would end up overwriting data)
	if ($IsEditing) {
		if (defined($BirthdayContents{$EventMonth}{$EventDay}{$Summary})) {
			unless ($EventMonth eq $OldEventMonth  and $EventDay eq $OldEventDay and $Summary eq $OldEventSummary) {
				DPError($Gettext->get(sprintf("A Birthday already exists for \"%s\" on %s %s", $Summary, $EventDay, $MonthNames{$EventMonth})));
				$Error = 1;
			}
		}
	} else {
		if (defined($BirthdayContents{$EventMonth}{$EventDay}{$Summary})) {
			DPError($Gettext->get(sprintf("A Birthday already exists for \"%s\" on %s %s", $Summary, $EventDay, $MonthNames{$EventMonth})));
			$Error = 1;
		}
	}
	unless ($Summary) {
		DPError($Gettext->get("A name is required to add a birthday"));
		$Error = 1;
	}
	# We don't do this if an error occurred
	unless ($Error) {
		# Delete old hash if needed
		if($IsEditing) {
			BirthdayDelete($OldEventMonth,$OldEventDay,$OldEventSummary);
		}
		# Add them to the hash
		$BirthdayContents{$EventMonth}{$EventDay}{$Summary} = 1;
		# Call UpdatedData to tell Day planner to save the data and redraw widgets
		UpdatedData();
		# Destroy our window, it will get the signal and do anything it needs to
		$MyWindow->destroy;
		$MainWindow->set_sensitive(1);
	}
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# GUI functions
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# USER DIALOGS

# Purpose: Display the about dialog
# Usage: AboutBox();
sub AboutBox () {
	$MainWindow->set_sensitive(0);
	my $AboutDialog = Gtk2::AboutDialog->new;
	$AboutDialog->set_transient_for($MainWindow);
	$AboutDialog->set_position('center-on-parent');
	$AboutDialog->set_authors("Eskild Hustvedt <zerodogg AT skolelinux DOT no>");
	$AboutDialog->set_artists("Jason Holland <jasonholland AT rawsoftware DOT com>");
	$AboutDialog->set_copyright("Copyright (C) Eskild Hustvedt 2006");
	$AboutDialog->set_website("http://home.gna.org/dayplanner/");
	$AboutDialog->set_name($Gettext->get("Day planner"));
	$AboutDialog->set_version($Version);
	# GPL summary, should never be marked as translateable
	$AboutDialog->set_license("Day planner is free software; you can redistribute it and/or\nmodify it under the terms of the GNU General Public License\nas published by the Free Software Foundation; either version 2\nof the License, or (at your option) any later version.\n\nDay planner is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty\nof MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with day planner; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.");
	# Logo
	my $LogoImage = DetectImage("dayplanner-about.png","dayplanner_48.png","dayplanner_24.png", "dayplanner_16.png", "dayplanner_HC48.png","dayplanner_HC24.png", "dayplanner_HC16.png", "dayplanner.png");
	if ($LogoImage) {
		my $PixBuf = Gtk2::Gdk::Pixbuf->new_from_file($LogoImage);
		$AboutDialog->set_logo($PixBuf);
	}
	# Translator credits
	unless ($Gettext->get("THE NAMES OF THE TRANSLATORS") eq "THE NAMES OF THE TRANSLATORS") {
		$AboutDialog->set_translator_credits($Gettext->get("THE NAMES OF THE TRANSLATORS"));
	}
	$AboutDialog->run;
	$MainWindow->set_sensitive(1);
}

# Purpose: Draw the preferences window and allow the user to set different
#  configuration options
# Usage: PreferencesWindow();
sub PreferencesWindow () {
	my $PreferencesWindow = Gtk2::Window->new();
	$PreferencesWindow->set_modal(1);
	$PreferencesWindow->set_transient_for($MainWindow);
	$PreferencesWindow->set_position('center-on-parent');
	$PreferencesWindow->set_title($Gettext->get("Preferences"));
	$PreferencesWindow->set_resizable(0);
	$PreferencesWindow->set_border_width(12);
	$PreferencesWindow->set_skip_taskbar_hint(1);
	$PreferencesWindow->set_skip_pager_hint(1);
	my $Tooltips = Gtk2::Tooltips->new();
	$Tooltips->enable();

	# Handle closing
	$PreferencesWindow->signal_connect("destroy" => sub { 
			SaveDefaultConfig();
			});
	
	# Creat the vbox
	my $Config_VBox = Gtk2::VBox->new();
	$Config_VBox->show();
	$PreferencesWindow->add($Config_VBox);
	
	# ==================================================================
	# GENERAL
	# ==================================================================
	
	# Create the primary vbox
	my $General_VBox = Gtk2::VBox->new();
	$General_VBox->show();
	$Config_VBox->pack_start($General_VBox,0,0,0);
	
	my $UI_Label = Gtk2::Label->new("<b>" . $Gettext->get("Interface") . "</b>");
	$UI_Label->set_use_markup(1);
	$UI_Label->set_alignment(0,1);
	$General_VBox->pack_start($UI_Label,0,0,0);
	$UI_Label->show();

	# EDITOR VERBOSE DEFAULT
	my $EDVDefaultCheckbox = Gtk2::CheckButton->new_with_label(sprintf($Gettext->get("Expand \"%s\" by default"), $Gettext->get("Details")));
	$General_VBox->pack_start($EDVDefaultCheckbox,0,0,0);
	$EDVDefaultCheckbox->show();
	if ($EditorVerboseDefault) {
		$EDVDefaultCheckbox->set_active(1);
	}
	$EDVDefaultCheckbox->signal_connect( "toggled" => sub {
			if ($EDVDefaultCheckbox->get_active) {
				$EditorVerboseDefault = 1;
			} else {
				$EditorVerboseDefault = 0;
			}
		});
	
	$Tooltips->set_tip($EDVDefaultCheckbox, sprintf($Gettext->get("Check this if you want the \"%s\" to be expanded by default in the add and edit events dialogues"), $Gettext->get("Details")));
	
	# ==================================================================
	# EVENTS
	# ==================================================================
	
	# A simple hash we use to parse back and forth between the PreNotification
	# combo box and the config option itself
	my %PreNotificationParser = (
		0 => '10min',
		1 => '20min',
		2 => '30min',
		3 => '45min',
		4 => '1hr',
		5 => '2hrs',
		6 => '4hrs',
		7 => '6hrs',
		
		'10min' => 0,
		'20min' => 1,
		'30min' => 2,
		'45min' => 3,
		'1hr' => 4,
		'1hrs' => 4,
		'2hr' => 5,
		'2hrs' => 5,
		'4hr' => 6,
		'4hrs' => 6,
		'6hr' => 7,
		'6hrs' => 7,

		'default' => 3,
		'readable_default' => '45mins',
	);
	
	# Create the vbox
	my $Events_VBox = Gtk2::VBox->new();
	$Events_VBox->show();
	$Config_VBox->pack_start($Events_VBox,0,0,0);

	# The label
	my $Events_Label = Gtk2::Label->new("<b>" . $Gettext->get("General events") . "</b>");
	$Events_Label->set_use_markup(1);
	$Events_Label->set_alignment(0,1);
	$Events_VBox->pack_start($Events_Label,0,0,0);
	$Events_Label->show();
	
	# The main checkbox that enables/disables the entire page
	my $Events_EnabledCheckbox = Gtk2::CheckButton->new_with_label($Gettext->get("Use notifications before events"));
	$Events_EnabledCheckbox->show();
	$Events_VBox->pack_start($Events_EnabledCheckbox,0,0,0);
	$Tooltips->set_tip($Events_EnabledCheckbox, $Gettext->get("Check this if you want day planner to notify you about events before they take place"));

	# The widgets that selects when the user wants to be notified
	# The HBox
	my $TimeSel_HBox = Gtk2::HBox->new();
	$Events_VBox->pack_start($TimeSel_HBox,0,0,0);
	$TimeSel_HBox->show();
	# The label
	my $TimeSel_Label = Gtk2::Label->new($Gettext->get('Time before the event to display the notification') . ': ');
	$TimeSel_Label->show();
	$TimeSel_HBox->pack_start($TimeSel_Label,0,0,0);
	# The combo box
	my $TimeSel_Combo = Gtk2::ComboBox->new_text();
	$TimeSel_Combo->insert_text(0, sprintf($Gettext->get("%s minutes"),"10"));
	$TimeSel_Combo->insert_text(1, sprintf($Gettext->get("%s minutes"),"20"));
	$TimeSel_Combo->insert_text(2, sprintf($Gettext->get("%s minutes"),"30"));
	$TimeSel_Combo->insert_text(3, sprintf($Gettext->get("%s minutes"),"45"));
	$TimeSel_Combo->insert_text(4, sprintf($Gettext->get("%s hour"),"1"));
	$TimeSel_Combo->insert_text(5, sprintf($Gettext->get("%s hours"),"2"));
	$TimeSel_Combo->insert_text(6, sprintf($Gettext->get("%s hours"),"4"));
	$TimeSel_Combo->insert_text(7, sprintf($Gettext->get("%s hours"),"6"));
	# Set the value
	if($Events_NotifyPre eq "0") {
		$TimeSel_Combo->set_active(3);
	} elsif (defined($PreNotificationParser{$Events_NotifyPre})) {
		$TimeSel_Combo->set_active($PreNotificationParser{$Events_NotifyPre});
	} else {
		$TimeSel_Combo->set_active($PreNotificationParser{'default'});
	}
	$TimeSel_Combo->show();
	$TimeSel_HBox->pack_start($TimeSel_Combo,0,0,0);
	# Register the changed signal
	$TimeSel_Combo->signal_connect('changed' => sub {
				$Events_NotifyPre = $PreNotificationParser{$TimeSel_Combo->get_active};
			});
	
	# If the user wants to be notified in advance
	my $NotifyAdvance_CheckBox = Gtk2::CheckButton->new_with_label($Gettext->get("Warn me one day in advance"));
	$NotifyAdvance_CheckBox->show();
	$Events_VBox->pack_start($NotifyAdvance_CheckBox,0,0,0);
	$NotifyAdvance_CheckBox->signal_connect('toggled' => sub {
			$Events_DayNotify = $NotifyAdvance_CheckBox->get_active();
		});
	if($Events_DayNotify) {
		$NotifyAdvance_CheckBox->set_active(1);
	}
	$Tooltips->set_tip($NotifyAdvance_CheckBox, $Gettext->get("Check this if you want day planner to warn you about events one day before they take place"));
	
	# This needs to be at the bottom so that we can sensitiveize or not the rest of the dialog
	$Events_EnabledCheckbox->signal_connect('toggled' => sub {
			if($Events_EnabledCheckbox->get_active) {
				$TimeSel_Combo->set_sensitive(1);
				$TimeSel_Label->set_sensitive(1);
				$NotifyAdvance_CheckBox->set_sensitive(1);
				$Events_NotifyPre = $PreNotificationParser{$TimeSel_Combo->get_active};
			} else {
				$TimeSel_Combo->set_sensitive(0);
				$TimeSel_Label->set_sensitive(0);
				$NotifyAdvance_CheckBox->set_sensitive(0);
				$Events_NotifyPre = 0;
			}
		});
	if($Events_NotifyPre) {
		$Events_EnabledCheckbox->set_active(1);
	} else {
		$Events_EnabledCheckbox->set_active(0);
		$TimeSel_Combo->set_sensitive(0);
		$TimeSel_Label->set_sensitive(0);
		$NotifyAdvance_CheckBox->set_sensitive(0);
	}
	
	# ==================================================================
	# FINALIZE WINDOW
	# ==================================================================
	# Add the buttons
	my $ButtonHBox = Gtk2::HBox->new();
	$ButtonHBox->show();
	$Config_VBox->pack_start($ButtonHBox,0,0,0);

	my $CloseButton = Gtk2::Button->new_from_stock('gtk-close');
	$CloseButton->signal_connect("clicked" => sub { 
			$PreferencesWindow->destroy;
		});
	$CloseButton->show();
	$ButtonHBox->pack_end($CloseButton,0,0,0);

	# Show the config window
	$PreferencesWindow->show();
}

# MAIN WINDOW

# Purpose: Draw the eventlist on the currently selected date in the calendar
# Usage: DrawEventlist();
sub DrawEventlist() {
	my $Year = $CalendarWidget->year;
	my $Month = $CalendarWidget->month;$Month++;
	my $Day = $CalendarWidget->selected_day;
	unless ($EventlistWidget) {
		$EventlistWidget = Gtk2::SimpleList->new (
			$Gettext->get("Time") => 'text',
			$Gettext->get("Event") => 'text',
		);
		$EventlistWin->add($EventlistWidget);
	} else {
		@{$EventlistWidget->{data}} = ();
	}
	# Main calendar contents
	if (defined($CalendarContents{$Year}) and defined($CalendarContents{$Year}{$Month}) and defined($CalendarContents{$Year}{$Month}{$Day})) {
		foreach my $Time (sort keys %{$CalendarContents{$Year}{$Month}{$Day}}) {
			unless (defined($CalendarContents{$Year}{$Month}{$Day}{$Time}{"summary"})) {
				DPIntWarn("Found no summary for entry: $Time");
			} else {
				push (@{$EventlistWidget->{data}}, [$Time, $CalendarContents{$Year}{$Month}{$Day}{$Time}{"summary"}]);
			}
		}
	}
	if (defined($BirthdayContents{$Month}) and defined($BirthdayContents{$Month}{$Day})) {
		foreach my $Birthday (sort keys %{$BirthdayContents{$Month}{$Day}}) {
			push (@{$EventlistWidget->{data}}, ["", sprintf($Gettext->get("%s's birthday"), $Birthday)]);
		}
	}
	# Register doubleclick (FIXME)
#	$EventlistWidget->signal_connect("row_activated" => \&EditEvent);
#	FIXME: We need this to work
#	$EventlistWidget->get_model->signal_connect('changed' => sub {
#			$ToolbarEditButton->set_sensitive(1);
#		});
#	$ToolbarEditButton->set_sensitive(0);
	$EventlistWidget->show();
}

# Purpose: Draw the main window
# Usage: DrawMainWindow();
sub DrawMainWindow () {
	# ==================================================================
	# BUILD THE MAIN WINDOW
	# ==================================================================
	# Create the main window widget
	$MainWindow = Gtk2::Window->new('toplevel');
	$MainWindow->set_title($Gettext->get("Day planner"));
	$MainWindow->set_default_size ($MainWin_Width,$MainWin_Height);
	$MainWindow->maximize if ($MainWin_Maximized);

	# Set the icon
	my $MainWindowIcon = DetectImage("dayplanner_48.png","dayplanner_24.png", "dayplanner_16.png", "dayplanner_HC48.png","dayplanner_HC24.png", "dayplanner_HC16.png", "dayplanner.png");
	if ($MainWindowIcon) {
		$MainWindow->set_default_icon_from_file($MainWindowIcon);
	}

	# Make it handle closing
	$MainWindow->signal_connect("destroy" => \&QuitSub);
	$MainWindow->signal_connect("delete-event" => \&QuitSub);

	# Handle saving maximized state
	$MainWindow->signal_connect(window_state_event => sub {
		my ($widget, $event) = @_;
		$MainWin_Maximized = ($event->new_window_state & 'maximized');
	});
		

	# Create the primary VBox for use inside it
	my $PrimaryWindowVBox = Gtk2::VBox->new();
	$PrimaryWindowVBox->show();
	$MainWindow->add($PrimaryWindowVBox);

	# ==================================================================
	# MENUBAR
	# ==================================================================
	# The menu items
	my @MenuItems = (
		# Calendar menu
		[ "/" . $Gettext->get("_Calendar"),						undef,			undef,			0,	"<Branch>"],
		[ "/" . $Gettext->get("_Calendar") . "/tearoff",				undef,			undef,			0,	"<Tearoff>"],
		[ "/" . $Gettext->get("_Calendar") . "/" . $Gettext->get("_Add an event"),		"<control>A",		\&AddEvent,		1,	'<StockItem>',	'gtk-add' ],
		[ "/" . $Gettext->get("_Calendar") . "/" . $Gettext->get("_Edit this event"),	"<control>E",		\&EditEvent,		2,	'<StockItem>',	'gtk-edit' ],
		[ "/" . $Gettext->get("_Calendar") . "/" . $Gettext->get("_Delete this event"),	"<control>D",		\&DeleteEvent,		3,	'<StockItem>',	'gtk-delete' ],
		[ "/" . $Gettext->get("_Calendar") . "/sep1",					undef,			undef,			4,	"<Separator>"],
		[ "/" . $Gettext->get("_Calendar") . "/" . $Gettext->get("_Preferences"),		undef,			\&PreferencesWindow,		5, 	'<StockItem>', 'gtk-preferences' ],
		[ "/" . $Gettext->get("_Calendar") . "/sep2",					undef,			undef,			6,	'<Separator>'],
		[ "/" . $Gettext->get("_Calendar") . "/" . $Gettext->get("_Quit"),		"<control>Q",		\&QuitSub,		0,	"<StockItem>",	'gtk-quit'],
		# Help menu
		[ "/" . $Gettext->get("_Help"),						undef,			undef,			0,	"<Branch>" ],
		[ "/" . $Gettext->get("_Help") . "/" . $Gettext->get("_About"),			undef,			\&AboutBox,		0,	'<StockItem>',	'gtk-about'],
	);
	# The accelgroup to use for the menuitems
	my $Menu_AccelGroup = Gtk2::AccelGroup->new;
	$MainWindow->add_accel_group($Menu_AccelGroup);
	# The item factory (menubar) itself
	my $Menu_ItemFactory = Gtk2::ItemFactory->new('Gtk2::MenuBar', '<main>', $Menu_AccelGroup);
	# Tell the item factory to use the items defined in @MenuItems
	$Menu_ItemFactory->create_items (undef, @MenuItems);
	# Pack it onto the vbox
	$PrimaryWindowVBox->pack_start($Menu_ItemFactory->get_widget("<main>"), 0, 0, 0);
	# Show it
	$Menu_ItemFactory->get_widget("<main>")->show();
	
	# ==================================================================
	# TOOLBAR
	# ==================================================================
	$Toolbar = Gtk2::Toolbar->new();
	$PrimaryWindowVBox->pack_start($Toolbar,0,0,0);
	$Toolbar->show();

	# Edit button
	$ToolbarEditButton = Gtk2::ToolButton->new_from_stock('gtk-edit');
	$ToolbarEditButton->signal_connect('clicked' => \&EditEvent);
	$Toolbar->insert($ToolbarEditButton,0);
	# TODO: This should be uncommented again once the signal is ready
	#$ToolbarEditButton->set_sensitive(0);
	$ToolbarEditButton->show();
	
	# Add button
	my $AddButton = Gtk2::ToolButton->new_from_stock('gtk-add');
	$AddButton->signal_connect("clicked" => \&AddEvent);
	$Toolbar->insert($AddButton,0);
	$AddButton->show();

	$Toolbar->get_nth_item(0)->set_is_important(1);
	$Toolbar->get_nth_item(1)->set_is_important(1);

	# ==================================================================
	# WORKING AREA
	# ==================================================================
	# Create the hbox which will contain the rest of the program
	$WorkingAreaHBox = Gtk2::HBox->new();
	$WorkingAreaHBox->show();
	# Add it to the primary VBox
	$PrimaryWindowVBox->pack_start($WorkingAreaHBox,1,1,0);
	
	# ==================================================================
	# THE RIGHT HAND AREA
	# ==================================================================
	
	# Create the vbox for use in it
	my $RightHandVBox = Gtk2::VBox->new();
	$WorkingAreaHBox->pack_end($RightHandVBox,0,0,0);
	$RightHandVBox->show();

	# CALENDAR
	# Create the calendar
	$CalendarWidget = Gtk2::Calendar->new;
	GetDate();
	SetActiveCalItems($curryear, $currmonth);
	$CalendarWidget->show();
	$CalendarWidget->display_options(['show-week-numbers', 'show-day-names','show-heading']);
	$RightHandVBox->pack_start($CalendarWidget,0,0,0);

	$CalendarWidget->signal_connect('prev-month' => \&CalendarChange);
	$CalendarWidget->signal_connect('next-month' => \&CalendarChange);
	$CalendarWidget->signal_connect('prev-year' => \&CalendarChange);
	$CalendarWidget->signal_connect('next-year' => \&CalendarChange);
	$CalendarWidget->signal_connect('day-selected' => \&DrawEventlist);

	# UPCOMING EVENTS
	# Create the (placeholder for the) upcoming events widget
#	my $UpcomingEventsWidget = Gtk2::Label->new($Gettext->get("Upcoming events..."));
#	$UpcomingEventsWidget->show();
#	$RightHandVBox->pack_end($UpcomingEventsWidget,0,0,0);
	
	# ==================================================================
	# TASK LIST
	# ==================================================================
	
	# Add a window for use for it
	$EventlistWin = Gtk2::ScrolledWindow->new;
	$EventlistWin->set_policy('automatic', 'automatic');
	$WorkingAreaHBox->pack_start($EventlistWin,1,1,0);
	$EventlistWin->show();
	
	# Draw the initial eventlist
	DrawEventlist();
	
	# ==================================================================
	# FINALIZE AND DISPLAY
	# ==================================================================

	# Finally, show the window and rest in the main Gtk2 loop
	$MainWindow->show();
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Core functions
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Get commandline options
GetOptions (
	'help|h' => sub {
		print "Day planner version $Version\n\n";
		my $ShortSaveDir = $SaveToDir;
		$ShortSaveDir =~ s/^$ENV{HOME}/~/;
		PrintHelp("-h","--help","Display this help screen and exit");
		PrintHelp("-v","--version", "Display version information and exit");
		PrintHelp("-t","--test","Use $ShortSaveDir/debug instead of $ShortSaveDir");
		PrintHelp("", "--confdir", "Use the directory supplied as configuration directory");
		PrintHelp("", "", "instead of $ShortSaveDir");
		PrintHelp("","--debuginfo", "Display information useful for debugging and exit");
		exit(0);
	},
	'version|v' => sub {
		print "Day planner version $Version\n";
		print "RCS revision: $RCSRev\n";
		exit(0);
	},
	'debuginfo' => sub {
		print "Day planner version $Version\n";
		print "RCS revision: $RCSRev\n";
		print "Gtk2 version ", join (".", Gtk2->GET_VERSION_INFO),"\n";
		printf "Perl version %vd\n", $^V;
		foreach(qw/mandriva mandrakelinux mandrake fedora redhat red-hat ubuntu lsb debian gentoo suse distro dist slackware NULL/) {
			if (-e "/etc/$_-release" or -e "/etc/$_-version" or -e "/etc/${_}_version" or $_ eq "NULL") {
				my ($DistVer, $File);
				if(-e "/etc/$_-release") {
					$File = "$_-release";
					open(VERSION_FILE, "<", "/etc/$_-release");
					$DistVer = <VERSION_FILE>;
				} elsif (-e "/etc/$_-version") {
					$File = "$_-version";
					open(VERSION_FILE, "<", "/etc/$_-release");
					$DistVer = <VERSION_FILE>;
				} elsif (-e "/etc/${_}_version") {
					$File = "${_}_version";
					open(VERSION_FILE, "<", "/etc/${_}_version");
					$DistVer = <VERSION_FILE>;
				} elsif ($_ eq "NULL") {
					last unless -e "/etc/version";
					$File = 'version';
					open(VERSION_FILE, "<", "/etc/version");
					$DistVer = <VERSION_FILE>;
				}
				chomp($DistVer);
				print "/etc/$File: $DistVer\n";
				last;

			}
		}
		exit(0);
	},
	'test|t' => sub {
		print "*** (Day Planner $Version) Running in test mode\n";
		$SaveToDir = "$SaveToDir/debug";
	},
	'confdir=s' => sub {
		if (-e $_[1]) {
			unless (-d $_[1]) {
				die "$_[1] is not a directory\n";
			}
			unless (-w $_[1]) {
				die "$_[1] is not writeable\n";
			}
		}
		$SaveToDir = $_[1];
	},
) or die "Run $0 --help for more information\n";

my $Gtk2_Initialized = 0;

# Load the configuration file
LoadDefaultConfig();
# Load the calendar
LoadCalendar();
unless($Gtk2_Initialized) {
	Gtk2->init;
}
# Initialize the daemon, and if it works draw the main window
if(DaemonInit()) {
	# Load the state file and draw the main window
	LoadStateFile($SaveToDir, "state.conf");
	DrawMainWindow();
} else {
	die "FATAL: Unable to initialize the daemon\n";
}
# Rest in the Gtk2 main loop
Gtk2->main;
