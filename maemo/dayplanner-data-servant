#!/usr/bin/perl
# dayplanner-data-servant
# Data servant for the Day Planner maemo client
#
# This is a sort of dayplanner-daemon meets dayplanner
# Copyright (C) Eskild Hustvedt 2008
#
# $Id$
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

use strict;
use warnings;

# We use IO::Socket for communication with dayplanenr and
# IO::Select to wait for connections and a timeout
use IO::Socket;
use IO::Select;
# These constants prettify things
use constant { true => 1, false => 0 };
# Parameter parser
use Getopt::Long;
Getopt::Long::Configure ('bundling', 'prefix_pattern=(--|-)');
# Used to locate the notifier
use Cwd;
use File::Basename;
# We need mktime and setsid
use POSIX qw/ mktime setsid/;		# We need setsid();
# Used to locate our own modules
use FindBin;			# So that we can detect module dirs during runtime
# This here is done so that we can use local versions of our libs
use lib "$FindBin::RealBin/modules/";
use lib "$FindBin::RealBin/modules/DP-iCalendar/lib/";
use lib "$FindBin::RealBin/modules/DP-GeneralHelpers/lib/";
use lib "$FindBin::RealBin/modules/DP-CoreModules/lib/";
use lib "$FindBin::RealBin/../modules/";
use lib "$FindBin::RealBin/../modules/DP-iCalendar/lib/";
use lib "$FindBin::RealBin/../modules/DP-GeneralHelpers/lib/";
use lib "$FindBin::RealBin/../modules/DP-CoreModules/lib/";
# Day Planner-specific libs
use DP::iCalendar qw(iCal_ConvertToUnixTime); # iCalendar support
use DP::GeneralHelpers qw(DPIntWarn DPIntInfo WriteConfigFile LoadConfigFile AppendZero);
use DP::CoreModules;

# The path to us
my $Self = $0;
# Set the name
$0 = 'dayplanner-data-servant';
# Our version number
my $Version = 0.9;
# The version name. Used for SVN detection
my $VersionName = 'SVN';
# Our RCS revision
my $RCSRev = '$Id$';
# The iCalendar object
my $iCalendar;
# The Day Planner directory
my $SaveToDir; 
# The calendar filename
my $CalendarFile = 'calendar.ics';
# The socket path
my $SocketPath;
# The socket FH
my $ServerSocket;
# The connection selection object
my $ConnectionSelector;
# The socket filename
my $OrigSocketName = 'Data_Servant';
my $SocketName = $OrigSocketName;
my $ConfigFile = 'dayplanner.maemo.conf';

my %UserConfig;

# Change this to make it daemonize properly
my $NoFork = true;
my $ForceFork = false;

# Purpose: Output log information.
# Usage: DaemonLog(LEVEL,Message);
# 	LEVEL is an int:
# 	0  - Critical
# 	1  - Error
# 	2  - Warning
#   3  - Notification
# 	4  - Debugging
#   5  - Calltrace
sub DaemonLog
{
	print $_[1]."\n";
	return;
}

# Purpose: Initialize data paths
# Usage: InitDataPaths();
sub InitDataPaths
{
	# First find the conf dir
	if(not $SaveToDir)
	{
		$SaveToDir = DetectConfDir(true);
		if(not -d $SaveToDir)
		{
			P_CreateSaveDir($SaveToDir);
		}
	}
	# Set the path to the socket and logfile
	$SocketPath = $SaveToDir . '/' . $SocketName;
}

# Purpose: Go into daemon mode
# Usage: Daemonize();
sub Daemonize
{
	my $Logfile = '/dev/null';
	# Fork
	my $PID = fork;
	exit if $PID;
	die "Unable to fork: $!\nYou may want to try --nofork\n" if not defined($PID);
	# Create a new session
	setsid() or DaemonLog(1,"Unable to start a new POSIX session (setsid()): $!");
	# Change dir to / - this to avoid clogging up a mountpoint
	chdir('/') or DaemonLog(1,"Unable to chdir to /: $!");
	# (We finish the daemonizing after loading the config and calendar)
	# FIXME
	open(STDIN, '<', '/dev/null') or DaemonLog(1,"Couldn't reopen STDIN to /dev/null: $!");
#	open(STDOUT, '>>', $Logfile) or DaemonLog(1,"Couldn't reopen STDOUT to $Logfile: $!");
#	open(STDERR, '>>', $Logfile) or DaemonLog(1,"Couldn't reopen STDERR to $Logfile: $!");
}

# Purpose: Load or reload the calendar data
# Usage: LoadData();
sub LoadData
{
	if($iCalendar)
	{
		DaemonLog(5,'Data reloaded');
		$iCalendar->reload();
		CalculateNotifications();
	}
	else
	{
		if (-e $SaveToDir.'/'.$CalendarFile)
		{
			$iCalendar = DP::iCalendar->new($SaveToDir.'/'.$CalendarFile);
		}
		else
		{
			$iCalendar = DP::iCalendar->newfile($SaveToDir.'/'.$CalendarFile);
			if (not $iCalendar)
			{
				die("FATAL: Unable to create a ->new() or a ->newfile() DP::iCalendar object!\n");
			}
		}
	}
}

# Purpose: Write the configuration file
# Usage: WriteConfig(DIRECTORY, FILENAME);
sub WriteConfig {
	P_WriteConfig($SaveToDir,$ConfigFile,%UserConfig);
}

# Purpose: Load the configuration file
# Usage: LoadConfig();
sub LoadConfig {
	%UserConfig = P_LoadConfig($SaveToDir,$ConfigFile);
	return(1);
}

# Purpose: This is the main loop of the daemon. It should never return.
# Usage: MainLoop();
# 	The data should be loaded, notifications calculated and socket opened before running this
#    - to put it simply. Never run directly. Run DaemonInit();
sub MainLoop
{
	DaemonLog(5,'Entering main loop');
	while(true)
	{
		# Block until one handle is available or it times out
		my @Ready_Handles = $ConnectionSelector->can_read();
		DaemonLog(5,'Main loop processing');
		foreach my $Handle (@Ready_Handles)
		{
			# If the handle is $ServerSocket then it's a new connection
			if ($Handle eq $ServerSocket)
			{
				my $NewClient = $ServerSocket->accept();
				$ConnectionSelector->add($NewClient);
				DaemonLog(4,'New handle '.$NewClient);
			} 
			# Handle isn't $ServerSocket, it's an existing connection trying to tell us something
			else
			{
				# What is it trying to tell us?
				my $Command = <$Handle>;
				# If it is defined then it's a command
				if ($Command)
				{
					chomp($Command);
					my ($Reply) = CommandHandler($Command,$Handle);
					DaemonLog(5,'Returning '.$Reply);
					print $Handle "$Reply\n";
				} 
				# If it isn't, then it closed the connection
				else
				{
					$ConnectionSelector->remove($Handle);
					DaemonLog(4,'Handle removed ',$Handle);
				}
			}
		}
	}
}

# Purpose: Perform initialization, then rest in the main loop
# Usage: InitDaemon();
sub InitDaemon
{
	DaemonLog(5,'Initializing');
	# Initialize data paths
	InitDataPaths();
	# Now try to open our socket. If that fails OpenSocket() will die() for us.
	OpenSocket();
	if ($ForceFork or not $NoFork)
	{
		Daemonize();
	}
	# Load our data
	LoadData();
	# Load the Day Planner config
	LoadConfig();
	# Okay, all initialiation has been done. Just rest in the main loop.
	MainLoop();
	# This should never happen
	die('FATAL ERROR: MainLoop() returned');
}

# Purpose: Open our main communication socket
# Usage: OpenSocket();
sub OpenSocket {
	if (-e $SocketPath) {
		die("$SocketPath: existed\n");
	}
	$ServerSocket = IO::Socket::UNIX->new(
					Local	=> $SocketPath,
					Type	=> SOCK_STREAM,
					Listen	=> 5,
			) or die "Unable to create a new socket: $@($!)\n";
	# Enforce strict permissions
	chmod(oct(600),$SocketPath);
	# Trap SIGPIPE
	$SIG{PIPE} = \&SigPipeHandler;
	# Create a new select handle for reading
	$ConnectionSelector = IO::Select->new();
	# Add the main server
	$ConnectionSelector->add($ServerSocket);

	DaemonLog(3,'Now listening on '.$SocketPath);
}

# Purpose: Handle incoming daemon commands
# Usage: $Return = CommandHandler(LINE,HANDLE);
sub CommandHandler 
{
	$_ = shift;
	my $Handle = shift;
	DaemonLog(5,$_);
	my $PID = $_;
	$PID =~ s/^(\d+)\s+(.*)/$1/;
	unless ($PID) {
		DaemonLog(3,"Malformed request: $_");
		return('ERR MALFORMED_REQUEST');
	}
	study();
	s/^(\d+)\s+//;
	if(/^SHUTDOWN/)
	{
		Shutdown("Requested by $PID");
	}
	elsif (/^VERSION/)
	{
		return($Version);
	}
	elsif(/^PING/)
	{
		return('PONG');
	}
	else
	{
		return('ERR INVALID_COMMAND');
	}
	
}

# Purpose: Convert to communication hash format
# Usage: GetComHash(HASH);
sub GetComHash
{
	my %Hash = shift;
	my $ret = 'HASH: ';
	foreach my $key(%Hash)
	{
		$Hash{$key} = GetComString($Hash{$key});
	}
	foreach my $key(%Hash)
	{
		# FIXME
		if(ref($Hash{$key}))
		{
			die("UNHANDLED HASH ELEMENT IS REFERENCE!");
		}
		$ret .= 'k:'.$key.'v:'.$Hash{$key}.'{DPSEP}';
	}
	return $ret;
}

# Purpose: Convert to communication array format
# Usage: GetComArray(ARRAY);
sub GetComArray
{
	my $ret = 'ARRAY: ';
	foreach my $v (@_)
	{
		$ret .= GetComString($v).'{DPSEP}';
	}
	return $ret;
}

# Purpose: Convert to communication string format
# Usage: GetComString(STRING);
sub GetComString
{
	$_ = shift;
	s/\n/{DPNL}/g;
	s/\r//g;
	return($_);
}

# Purpose: Convert from communication string format
# Usage: UnGetComString(STRING);
sub UnGetComString
{
	$_ = shift;
	s/{DPNL}/\n/g;
	return($_);
}

InitDaemon();
