#!/usr/bin/perl
# dayplanner-data-servant
# Data servant for the Day Planner maemo client
#
# This is a sort of dayplanner-daemon meets dayplanner
# Copyright (C) Eskild Hustvedt 2008
#
# $Id$
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

use strict;
use warnings;

# We use IO::Socket for communication with dayplanenr and
# IO::Select to wait for connections and a timeout
use IO::Socket;
use IO::Select;
# These constants prettify things
use constant { true => 1, false => 0 };
# Parameter parser
use Getopt::Long;
Getopt::Long::Configure ('bundling', 'prefix_pattern=(--|-)');
# We need mktime and setsid
use POSIX qw/ mktime setsid/;		# We need setsid();
# Day Planner-specific libs
use DP::iCalendar qw(iCal_ParseDateTime iCal_GenDateTime); # iCalendar support
use DP::GeneralHelpers qw(DPIntWarn DPIntInfo WriteConfigFile LoadConfigFile AppendZero);
use DP::CoreModules;

# The path to us
my $Self = $0;
# Set the name
$0 = 'dayplanner-data-servant';
# Our version number
my $Version = 0.9;
# The version name. Used for SVN detection
my $VersionName = 'SVN';
# Our RCS revision
my $RCSRev = '$Id$';
# The iCalendar object
my $iCalendar;
# The Day Planner directory
my $SaveToDir; 
# The calendar filename
my $CalendarFile = 'calendar.ics';
# The socket path
my $SocketPath;
# The socket FH
my $ServerSocket;
# The connection selection object
my $ConnectionSelector;
# The socket filename
my $OrigSocketName = 'Data_Servant';
my $SocketName = $OrigSocketName;
my $ConfigFile = 'dayplanner.maemo.conf';

my %UserConfig;

# Change this to make it daemonize properly
my $NoFork = true;
my $ForceFork = false;
my $LogLevel = 1;

$SIG{INT} = sub { Shutdown('SIGINT');};
$SIG{TERM} = sub { Shutdown('SIGTERM');};

# The maemo doesn't have these :(
sub encode_utf8
{
	if(wantarray())
	{
		return(@_);
	}
	return shift;
}
sub decode_utf8
{
	if(wantarray())
	{
		return(@_);
	}
	return shift;
}

# Purpose: Shut down.
# Usage: Shutdown(reason);
sub Shutdown
{
	my $reason = shift;
	$iCalendar->write();
	DaemonLog(5,"Shutdown due to: $reason");
	unlink($SocketPath) if -e $SocketPath;
	exit(0);
}

# Purpose: Handle SIGPIPEs properly. Runs sanity checks on handles and shuts down if needed
sub SigPipeHandler
{
	DaemonLog(4, "SIGPIPE, running sanity checks");
	my @Handles = $ConnectionSelector->handles();
	if (scalar(@Handles) <= 0)
	{
		Shutdown("No handles left");
	}
	else
	{
		my $def = false;
		foreach my $h(@Handles)
		{
			if(defined($h))
			{
				$def = true;
			}
		}
		if (not $def)
		{
			Shutdown("No defined handles left");
		}
	}
	DaemonLog(4,"Handles are OK, not shutting down");
}

# Purpose: i18n wrapper for CoreModules
# Usage: i18nwrapper(SAME AS $I18n->get);
sub i18nwrapper
{
	return(shift);
#	return($i18n->get(@_));
}

# Purpose: i18n wrapper for CoreModules
# Usage: i18nwrapper_advanced(SAME AS $I18n->get_advanced);
sub i18nwrapper_advanced
{
	my $String = shift;
	my $Values = shift;
	foreach my $Key (keys(%{$Values})) {
		$String =~ s/%\($Key\)/$Values->{$Key}/g;
	}
	return($String);
	#return($i18n->get_advanced(@_));
}

# Purpose: i18n wrapper for CoreModules
# Usage: i18nwrapper_AMPM_From24(SAME AS $I18n->AMPM_From24);
sub i18nwrapper_AMPM_From24
{
	return(shift);
	#return($i18n->AMPM_From24(@_));
}

sub GetSummaryString
{
	return P_GetSummaryString(undef,$iCalendar,@_);
}

# Purpose: Output log information.
# Usage: DaemonLog(LEVEL,Message);
# 	LEVEL is an int:
# 	0  - Critical
# 	1  - Error
# 	2  - Warning
#   3  - Notification
# 	4  - Debugging
#   5  - Calltrace
sub DaemonLog
{
	my $Level = shift;
	return if not($Level <= $LogLevel);
	my $Message = shift;
	my $MsgPrefix;
	if($Level == 0 or $Level == 1)
	{
		$MsgPrefix = 'Error:        ';
	}
	elsif($Level == 2)
	{
		$MsgPrefix = 'Warning:      ';
	}
	elsif($Level == 3)
	{
		$MsgPrefix = 'Notification: ';
	}
	elsif($Level == 4)
	{
		$MsgPrefix = 'Debug:        ';
	}
	elsif($Level == 5)
	{
		$MsgPrefix = 'Calltrace:    ';
	}
	my ($lsec,$lmin,$lhour,$lmday,$lmon,$lyear,$lwday,$lyday,$lisdst) = GetDate(time());
	$lhour = "0$lhour" unless $lhour >= 10;
	$lmin = "0$lmin" unless $lmin >= 10;
	$lsec = "0$lsec" unless $lsec >= 10;
	print "[$lmday/$lmon/$lyear $lhour:$lmin:$lsec ($$)] ";
	print($MsgPrefix.$Message);
	print "\n";
}

# Purpose: Initialize data paths
# Usage: InitDataPaths();
sub InitDataPaths
{
	# First find the conf dir
	if(not $SaveToDir)
	{
		$SaveToDir = DetectConfDir(true);
		if(not -d $SaveToDir)
		{
			P_CreateSaveDir($SaveToDir);
		}
	}
	# Set the path to the socket and logfile
	$SocketPath = $SaveToDir . '/' . $SocketName;
}

# Purpose: Go into daemon mode
# Usage: Daemonize();
sub Daemonize
{
	my $Logfile = '/dev/null';
	# Fork
	my $PID = fork;
	exit if $PID;
	die "Unable to fork: $!\nYou may want to try --nofork\n" if not defined($PID);
	# Create a new session
	setsid() or DaemonLog(1,"Unable to start a new POSIX session (setsid()): $!");
	# Change dir to / - this to avoid clogging up a mountpoint
	chdir('/') or DaemonLog(1,"Unable to chdir to /: $!");
	# (We finish the daemonizing after loading the config and calendar)
	# FIXME
	open(STDIN, '<', '/dev/null') or DaemonLog(1,"Couldn't reopen STDIN to /dev/null: $!");
#	open(STDOUT, '>>', $Logfile) or DaemonLog(1,"Couldn't reopen STDOUT to $Logfile: $!");
#	open(STDERR, '>>', $Logfile) or DaemonLog(1,"Couldn't reopen STDERR to $Logfile: $!");
}

# Purpose: Load or reload the calendar data
# Usage: LoadData();
sub LoadData
{
	if($iCalendar)
	{
		DaemonLog(5,'Data reloaded');
		$iCalendar->reload();
		CalculateNotifications();
	}
	else
	{
		if (-e $SaveToDir.'/'.$CalendarFile)
		{
			$iCalendar = DP::iCalendar->new($SaveToDir.'/'.$CalendarFile);
		}
		else
		{
			$iCalendar = DP::iCalendar->newfile($SaveToDir.'/'.$CalendarFile);
			if (not $iCalendar)
			{
				die("FATAL: Unable to create a ->new() or a ->newfile() DP::iCalendar object!\n");
			}
		}
	}
}

# Purpose: Write the configuration file
# Usage: WriteConfig(DIRECTORY, FILENAME);
sub WriteConfig {
	P_WriteConfig($SaveToDir,$ConfigFile,%UserConfig);
}

# Purpose: Load the configuration file
# Usage: LoadConfig();
sub LoadConfig {
	%UserConfig = P_LoadConfig($SaveToDir,$ConfigFile);
	return(1);
}

# Purpose: This is the main loop of the daemon. It should never return.
# Usage: MainLoop();
# 	The data should be loaded, notifications calculated and socket opened before running this
#    - to put it simply. Never run directly. Run DaemonInit();
sub MainLoop
{
	DaemonLog(5,'Entering main loop');
	while(true)
	{
		# Block until one handle is available or it times out
		my @Ready_Handles = $ConnectionSelector->can_read();
		DaemonLog(5,'Main loop processing');
		foreach my $Handle (@Ready_Handles)
		{
			# If the handle is $ServerSocket then it's a new connection
			if ($Handle eq $ServerSocket)
			{
				my $NewClient = $ServerSocket->accept();
				$ConnectionSelector->add($NewClient);
				DaemonLog(4,'New handle '.$NewClient);
			} 
			# Handle isn't $ServerSocket, it's an existing connection trying to tell us something
			else
			{
				# What is it trying to tell us?
				my $Command = <$Handle>;
				# If it is defined then it's a command
				if ($Command)
				{
					chomp($Command);
					$Command = decode_utf8($Command);
					my ($Reply) = CommandHandler($Command,$Handle);
					DaemonLog(5,'Returning '.$Reply);
					print $Handle encode_utf8($Reply)."\n";
				} 
				# If it isn't, then it closed the connection
				else
				{
					$ConnectionSelector->remove($Handle);
					Shutdown("Handle removed: ".$Handle);
				}
			}
		}
	}
}

# Purpose: Perform initialization, then rest in the main loop
# Usage: InitDaemon();
sub InitDaemon
{
	DaemonLog(5,'Initializing');
	# Initialize data paths
	InitDataPaths();
	# Now try to open our socket. If that fails OpenSocket() will die() for us.
	OpenSocket();
	if ($ForceFork or not $NoFork)
	{
		Daemonize();
	}
	# Load our data
	LoadData();
	# Load the Day Planner config
	LoadConfig();
	# Okay, all initialiation has been done. Just rest in the main loop.
	MainLoop();
	# This should never happen
	die('FATAL ERROR: MainLoop() returned');
}

# Purpose: Open our main communication socket
# Usage: OpenSocket();
sub OpenSocket {
	if (-e $SocketPath) {
		my $TestSocket = IO::Socket::UNIX->new(Peer	=> $SocketPath,
							Type	=> SOCK_STREAM
							Timeout => 2);
		if (defined($TestSocket)) {
			# We could connect
			print $TestSocket "$$ SHUTDOWN\n";
		}
		unlink($SocketPath);
	}
	$ServerSocket = IO::Socket::UNIX->new(
					Local	=> $SocketPath,
					Type	=> SOCK_STREAM,
					Listen	=> 5,
			) or die "Unable to create a new socket: $@($!)\n";
	# Enforce strict permissions
	chmod(oct(600),$SocketPath);
	# Trap SIGPIPE
	$SIG{PIPE} = \&SigPipeHandler;
	# Create a new select handle for reading
	$ConnectionSelector = IO::Select->new();
	# Add the main server
	$ConnectionSelector->add($ServerSocket);

	DaemonLog(3,'Now listening on '.$SocketPath);
}

# Purpose: Handle incoming daemon commands
# Usage: $Return = CommandHandler(LINE,HANDLE);
sub CommandHandler 
{
	$_ = shift;
	my $Handle = shift;
	DaemonLog(5,$_);
	my $PID = $_;
	$PID =~ s/^(\d+)\s+(.*)/$1/;
	unless ($PID) {
		DaemonLog(3,"Malformed request: $_");
		return('ERR MALFORMED_REQUEST');
	}
	study();
	s/^(\d+)\s+//;
	if(/^SHUTDOWN/)
	{
		Shutdown("Requested by $PID");
	}
	elsif (/^VERSION/)
	{
		return($Version);
	}
	elsif(/^PING/)
	{
		return('PONG');
	}
	elsif(/^GET_UPCOMINGEVENTS/)
	{
		return(GetComString(GetUpcomingEventsString($iCalendar)));
	}
	elsif(/^GET_ICAL/)
	{
		my $UID = $_;
		$UID =~ s/^GET_ICAL\s+//;
		my $ret = $iCalendar->get_info($UID);
		if(ref($ret) eq 'HASH')
		{
			return(GetComHash(%{$ret}));
		}
		return("ERR UNKNWON_ERROR");
	}
	elsif(/^GET_EVENTS/)
	{
		my $year = $_;
		my $month = $_;
		my $day = $_;
		$year =~ s/^GET_EVENTS\s+(\d+).*/$1/;
		$month =~ s/^GET_EVENTS\s+\d+\s+(\d+).*/$1/;
		$day =~ s/^GET_EVENTS\s+\d+\s+\d+\s+(\d+).*/$1/;
		my @EventList;
		# Main calendar contents
		if (my $TimeArray = $iCalendar->get_dateinfo($year,$month,$day)) {
			foreach my $Time (sort @{$TimeArray}) {
				foreach my $UID (@{$iCalendar->get_timeinfo($year,$month,$day,$Time)}) {
					push(@EventList,$UID);
				}
			}
		}
		return(GetComArray(@EventList));
	}
	elsif(/^GET_DAYS/)
	{
		my $year = $_;
		my $month = $_;
		$year =~ s/^GET_DAYS\s+(\d+).*/$1/;
		$month =~ s/^GET_DAYS\s+\d+\s+(\d+).*/$1/;
		my $MonthInfo = $iCalendar->get_monthinfo($year,$month);
		my @array;
		if ($MonthInfo) {
			foreach my $Day (@{$MonthInfo}) {
				push(@array,$Day);
			}
		}
		return(GetComArray(@array));
	}
	elsif(/^GET_ICSTIME/)
	{
		my $time = $_;
		$time =~ s/^GET_ICSTIME\s+//;
		my ($Year, $Month, $Day, $Time) = iCal_ParseDateTime($time);
		return($Time);
	}
	elsif(/^GET_SUMMARY/)
	{
		my $UID = $_;
		$UID =~ s/^GET_SUMMARY\s+//;
		return GetSummaryString($UID);
	}
	else
	{
		return('ERR INVALID_COMMAND');
	}
	
}

# Purpose: Convert to communication hash format
# Usage: GetComHash(HASH);
sub GetComHash
{
	my %Hash = @_;
	my @Array;
	foreach my $key(keys %Hash)
	{
		my $newKey = GetComString($key);
		my $newEntry = GetComString($Hash{$key});
		delete($Hash{$key});
		push(@Array,$newKey);
		push(@Array,$newEntry);
	}
	return 'HASH'.GetComArray(@Array);
}

# Purpose: Convert to communication array format
# Usage: GetComArray(ARRAY);
sub GetComArray
{
	my $ret = 'ARRAY: ';
	foreach my $v (@_)
	{
		$ret .= GetComString($v).'{DPSEP}';
	}
	return $ret;
}

# Purpose: Convert to communication string format
# Usage: GetComString(STRING);
sub GetComString
{
	$_ = shift;
	return '' if not defined $_;
	s/\n/{DPNL}/g;
	s/\r//g;
	return($_);
}

# Purpose: Convert from communication array format
# Usage: UnGetComArray(STRING);
sub UnGetComArray
{
	my $string = shift;
	$string =~ s/^ARRAY: //;
	my @NewArray;
	foreach my $e (split(/{DPSEP}/,$string))
	{
		push(@NewArray,$e);
	}
	return(@NewArray);
}

# Purpose: Convert from communication hash format
# Usage: UnGetComHash(STRING);
sub UnGetComHash
{
	my $string = shift;
	$string =~ s/^HASH//;
	my %Hash = UnGetComArray($string);
	return(%Hash);
}

# Purpose: Convert from communication string format
# Usage: UnGetComString(STRING);
sub UnGetComString
{
	$_ = shift;
	s/{DPNL}/\n/g;
	return($_);
}

GetOptions (
	'v|verbose+' => \$LogLevel,
	'f|force-fork' => \$ForceFork,
	'n|nofork' => \$NoFork,
	'version' => sub {
		print "Day Planner maemo data servant daemon version $Version\n";
		print "RCS revision: $RCSRev\n";
		exit(0);
	},
) or die "See $0 --help for more information\n";

InitDaemon();
