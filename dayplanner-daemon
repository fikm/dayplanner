#!/usr/bin/perl
# Dayplanner daemon
# The notification daemon for day planner
# Copyright (C) Eskild Hustvedt 2006
# $Id$
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.

use strict;			# Force strict coding
use warnings;			# Tell perl to print warnings
use IO::Socket;			# We use IO::Socket for communication with dayplanner
use IO::Select;			# We use IO::Select to wait for connections and at the same
				#  time wait for a timeout
use Locale::gettext;		# Allow translation, might not be needed
use Getopt::Long;		# Commandline options
use Cwd;			# We need Cwd::realpath to find the notifier
use File::Basename;		# Ditto

Getopt::Long::Configure ("bundling", 'prefix_pattern=(--|-)');

# Scalars
my $Version = '0.1 Beta1';
my $RCSRev = '$Id$';
my $MainEventsFile = "events.dpd";		# The filename to read events from
my $BirthdayFile = "birthdays.dpd";		# The filename to read birthdays from
my $SpecialEventsFile = "events_special.dpd";	# The filename to read special events from
my $DaemonFile = 'daemondata.dpd';		# The filename to save and read daemon data from
my $ConfigFile = "dayplanner.conf";		# The dayplanner config - TODO: drop?
my $SocketName = "dayplannerd";			# The name of the socket to use
my $NotifierName = "dayplanner-notifier";	# The name of the dayplanner notifier
my (
	$NoFork,	$DayplannerDir,		$DaemonSocket,
	$Server,	$ConnectionSelect,	$ForceFork,
	$Shutdown,	$LastAlarm,		$OutputRedirect
);						# Global scalars

my (
	$DebuggingOutput,	$OutputVerbose,	$OutputVeryVerbose,
) = (0,0,0);

# Hashes
my %CalendarContents;		# Contents of the main calendar
my %BirthdayContents;		# Contents of the birthday calendar
my %SpecialEvents;		# Contents of the speical events calendar

my %AccessStatus = (
	Connected => 0,
	ClientList => {
	},
);				# Hash containing current connection status

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# HELPER FUNCTIONS
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Purpose: Print formatted --help output
# Usage: PrintHelp("-shortoption", "--longoption", "description");
sub PrintHelp($$$) {
	printf "%-4s %-16s %s\n", "$_[0]", "$_[1]", "$_[2]";
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# CORE CALENDAR FUNCTIONS
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Purpose: Load the calendar contents
# Usage: LoadCalendar();
sub LoadCalendar () {
	if(DataLoadTest("$DayplannerDir/$MainEventsFile")) {
		%CalendarContents = do("$DayplannerDir/$MainEventsFile");
	}
	if(DataLoadTest("$DayplannerDir/$BirthdayFile")) {
		%BirthdayContents = do("$DayplannerDir/$BirthdayFile");
	}
	if(DataLoadTest("$DayplannerDir/$SpecialEventsFile")) {
		%SpecialEvents = do("$DayplannerDir/$SpecialEventsFile");
	}
	return(1);
}

# Purpose: Test if a load can be successfully performed of the supplied file
# Usage: DataLoadTest("/path/to/file");
sub DataLoadTest () {
	# If the calendar savefile exists
	if (-e "$_[0]") {
		# If it isn't readable then we warn and return
		unless (-r "$_[0]") {
			DPIntWarn("Unable to read the calendar at $_[0]: It isn't readable by me");
			return(0);
		}
		# If it isn't writeable then we just warn (the file can still be loaded)
		unless (-w "$_[0]") {
			DPIntWarn("Unable to write the calendar at $_[0]: It isn't writeable by me. Expect trouble!");
		}
		return(1);
	} else {
		# If the file doesn't exist then we just assume that it isn't created yet,
		# so we return false, but do it silently.
		return(0);
	}
}

# Purpose: Find out how many seconds we should sleep before performing some action
# Usage: $SleepTime = FindSleepDuartion();
sub FindSleepDuration () {
	# Get the current time/date
	my ($currsec,$currmin,$currhour,$currmday,$currmonth,$curryear,$currwday,$curryday,$currisdst) = localtime(time);
	$curryear += 1900; $currmonth++;

	my @Keys;	# An array containing all the keys in a random order
	
	# First we find out which hashes has something for us
	# TODO: At some point we need to add the special and birthday hashes here too
	if (defined($CalendarContents{$curryear}{$currmonth}{$currmday})) {
			foreach (keys(%{$CalendarContents{$curryear}{$currmonth}{$currmday}})) {
					push(@Keys, $_);
			}
		}
	my ($hours, $minutes);
	# If keys is true then...
	if (@Keys) {
		@Keys = sort(@Keys);
		foreach (@Keys) {
			my ($testhours, $testminutes) = split(/:/, $_);
			# Uh, FIXME?
			$testhours =~ s/^0(.*)/$1/;
			$testminutes =~ s/^0(.*)/$1/;
			# TODO: This might need to become a bit more robust
			if($testhours < $currhour) {
				next;
			}
			if($testhours == $currhour and $testminutes < $currmin) {
				next;
			}
			if(defined($LastAlarm) and $LastAlarm eq "$testhours:$testminutes") {
				next;
			}
			$hours = $testhours;
			$minutes = $testminutes;
		}
	}
	# If keys is NOT set then we return the amount of seconds until midnight instead
	unless(defined($hours) and defined($minutes)) {
		$hours = 24;
		$minutes = 0;
	}
	# Convert hours to seconds
	$hours = $hours * 60 * 60;
	# Minutes to seconds
	$minutes = $minutes * 60;
	# Hours to seconds
	$currhour = $currhour * 60 * 60;
	# Minutes to seconds
	$currmin = $currmin * 60;
	# Only do it if $currsec is > 0
#	if($currsec) {
#		# Find the correct currsec value
#		$currsec = 59 - $currsec;
#	}
	# Calculate the total
	my $total = ($hours + $minutes) - ($currhour + ($currmin + $currsec));
	# Return the total to caller
	return($total);
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# CORE HELPER FUNCTIONS
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

# Purpose: Output a debugging stuff if needed
# Usage: IntDebug(MESSAGE);
sub IntDebug ($) {
	if ($DebuggingOutput) {
		IntOutputMSG("DEBUG: $_[0]\n");
	}
}

# Purpose: Output a message when in very verbose mode
# IntVeryVerbose(MESSAGE);
sub IntVeryVerbose ($) {
	if ($OutputVeryVerbose) {
		IntOutputMSG("$_[0]\n");
	}
}

# Purpose: Output a message when in verbose mode
# Usage: IntVerbose(MESSAGE);
sub IntVerbose ($) {
	if ($OutputVerbose) {
		IntOutputMSG("$_[0]\n");
	}
}

# Purpose: Output a properly formatted internal message
# Usage: IntOutputMSG(MESSAGE);
sub IntOutputMSG ($) {
	my ($lsec,$lmin,$lhour,$lmday,$lmon,$lyear,$lwday,$lyday,$lisdst) = localtime(time);
	$lhour = "0$lhour" unless $lhour >= 10;
	$lmin = "0$lmin" unless $lmin >= 10;
	$lsec = "0$lsec" unless $lsec >= 10;
	print "[$lhour:$lmin:$lsec] $_[0]";
}

# Purpose: Print a warning to STDERR with proper output
# Usage: DPIntWarn("Warning");
sub IntWarn ($) {
	warn "Warning: $_[0]\n";
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# CORE DAEMON FUNCTIONS
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Purpose: Start the notifier and display the alarm
# Usage: DayplannerAlarm();
sub DayplannerAlarm () {
	IntDebug("Alarm");
	# Get the current time/date
	my ($currsec,$currmin,$currhour,$currmday,$currmonth,$curryear,$currwday,$curryday,$currisdst) = localtime(time);
	$LastAlarm = "$currhour:$currmin";
	# Fix the format
	$currhour = "0$currhour" unless $currhour >= 10;
	$currmin = "0$currmin" unless $currmin >= 10;
	$currsec = "0$currsec" unless $currsec >= 10;
	$curryear += 1900;
	$currmonth++;
	if(defined($CalendarContents{$curryear}{$currmonth}{$currmday}{"$currhour:$currmin"})) {
			RunNotifier($CalendarContents{$curryear}{$currmonth}{$currmday}{"$currhour:$currmin"}{summary},
				$CalendarContents{$curryear}{$currmonth}{$currmday}{"$currhour:$currmin"}{fulltext},
				'today',
				"$currhour:$currmin");
	} else {
		IntDebug("Undefined CalendarContent - BUG! \$CalendarContents{$curryear}{$currmonth}{$currmday}{$currhour:$currmin}");
	}
}

# Purpose: Run the notifier itself with the correct parameters
# Usage: RunNotifier(SUMMARY, FULLTEXT, DATE, TIME);
sub RunNotifier ($$$$) {
	# Notifier
	my ($Summary, $Fulltext, $Date, $Time) = @_;
	IntDebug("Alarm! Task: $Summary at $Time on $Date");
	foreach(split(/:/, sprintf("%s:%s", $ENV{PATH}, dirname(Cwd::realpath($0))))) {
		if ( -x "$_/$NotifierName") {
			# Yes this is a bit weird statement. But remember that commands return 0 on TRUE
			# and 1-255 on FALSE, so it's the other way around from perl
			unless(system("$_/$NotifierName --socket \"$DaemonSocket\" --message \"$Summary\" --fulltext \"$Fulltext\" --time \"$Time\" --date \"$Date\"")) {
				return(1);
			}
		}
	}
	IntWarn("Unable to start the notifier! Task: $Summary at $Time on $Date");
}

# Purpose: Handle commands
# Usage: CommandHandler(COMMAND);
sub CommandHandler ($) {
	$_ = $_[0];
	my $PID = $_[0];
	$PID =~ s/^(\d+)\s+(.*)/$1/;
	unless ($PID) {
		IntDebug("Malformed request: $_");
		return("ERR MALFORMED_REQUEST");
	}
	s/^(\d+)\s+//;
	# HI is the first command clients should run to identify themselves
	if (/^HI\s+(\w+)/) {
		my $TYPE = $1;
		IntDebug("New connection ($TYPE), $PID says HI");
		if ($TYPE =~ /client/) {
			# We already have a client, refuse
			if ($AccessStatus{Connected}) {
				if ($_ =~ /FORCE/ ) {
					IntVeryVerbose("$PID is forcing a connection");
				} else {
					IntVeryVerbose("Refusing connection from $PID");
					delete($AccessStatus{ClientList}{$PID});
					return("REFUSED");
				}
			}
			$AccessStatus{Connected} = $PID;
		} elsif ($TYPE =~ /commander/) {
			IntDebug("New commander ($PID)");
		} elsif ($TYPE =~ /servant/) {
			IntDebug("New servant ($PID)");
		} else {
			IntDebug("Invalid type from $PID ($TYPE) - refusing");
			return("REFUSED");
		}
		$AccessStatus{ClientList}{$PID} = $TYPE;
		return("HI")
	}
	
	# Okay it isn't HI, check if we allow connections from it
	unless($AccessStatus{ClientList}{$PID}) {
		IntDebug("Disallowed client $PID wanted to run command $_ but was refused");
		return("REFUSED");
	}
	
	if (/^BYE/) {	# BYE is the last command clients should run, 
			# removes them from the internal access lists and unlocks if needed
		IntDebug("Closed connection, $PID says BYE");
		if($AccessStatus{ClientList}{$PID} eq 'client') {
			$AccessStatus{Connected} = 0;
		}
		delete($AccessStatus{ClientList}{$PID});
		return("BYE");
	} elsif (/^RELOAD_DATA/) {	# Command to force the daemon to reload the data files
		IntDebug("Data reload requested by $PID");
		LoadCalendar();
		IntDebug("Done reloading data");
		return("done");
	} elsif (/^SHUTDOWN/) {		# Command to force daemon shutdown
		IntDebug("Shutdown request");
		#	if($TYPE =~ /servant/) {
			#	return("ERR PERMISSION_DENIED");
			#} else {
			$Shutdown = "Daemon shut down by client ($PID) request";
			return("okay");
			#}
	} elsif (/^PING/) {		# Simple ping implementation
		IntDebug("Ping request from $PID");
		return("PONG");
	} 
	elsif (s/^DEBUG\s*//) {
		if (/^DUMP_VARIOUS/) {
			IntDebug("Recieved debugging info request from $PID");
			my $OutRedir = "None";
			if (defined($OutputRedirect) and length($OutputRedirect)) {
					$OutRedir = $OutputRedirect;
			}
			return("Version $Version - RCSRev $RCSRev || Using dir $DayplannerDir (socket name $SocketName) || AccessStatus{Connected} = $AccessStatus{Connected} || Output: $DebuggingOutput/$OutputVeryVerbose/$OutputVerbose || Output redirection: $OutRedir");
		} elsif (/^DUMP_CLIENTLIST/) {
			IntDebug("Client list request from $PID");
			my $ClientList;
			foreach (reverse sort keys(%{$AccessStatus{ClientList}})) {
				# There must be some better way to do this?
				if ($ClientList) {
					$ClientList = "$_ $ClientList";
				} else {
					$ClientList = $_;
				}
			}
			return($ClientList);
		} elsif (/^DUMP_SLEEPTIME/) {
			IntDebug("Sleep time request from $PID");
			return(FindSleepDuration());
		} elsif (/^KICK\s+(\w+)/) {
			my $CLIENT = $1;
			IntDebug("Client KICK request from $PID");
			if(defined($AccessStatus{ClientList}{$CLIENT})) {
				delete($AccessStatus{ClientList}{$CLIENT});
				return("CLIENT KICKED");
			} else {
				return("UNKNOWN CLIENT");
			}
		} elsif (/^ENABLE_DEBUGLOG/) {
			my $PATH = "$DayplannerDir/daemon.log";
			open(STDOUT, ">$PATH") or return("FAILED to open $PATH for writing: $!");
			open(STDERR, ">$PATH") or return("FAILED to open $PATH for writing: $!");
			$OutputRedirect = $PATH;
			$DebuggingOutput = 1;
			$OutputVeryVerbose = 1;
			$OutputVerbose = 1;
			return("SUCCESS - writing debugging information to $PATH");
		} else {
			IntDebug("Invalid debug command: \"$_\" from $PID");
			return("ERR INVALID_COMMAND");
		}
	}
	else {				# Handler for invalid requests
		IntDebug("Invalid command: $_ from $PID");
		return("ERR INVALID_COMMAND");
	}
}

# Purpose: Handle SIGPIPE gently
# Usage: $SIG{PIPE} = \&SigpipeHandler;
sub SigpipeHandler {
	IntDebug("Sigpipe");
}

# Purpose: Open our main communication socket
# Usage: OpenSocket();
sub OpenSocket () {
	if (-e $DaemonSocket) {
		my $TestSocket = IO::Socket::UNIX->new(Peer	=> $DaemonSocket,
							Type	=> SOCK_STREAM
							Timeout => 2);
		if (defined($TestSocket)) {
			# We could connect
			#
			# Now this isn't a nice way to do it, but we do it anyway
			print $TestSocket "$$ HI commander\n";
			my $CommanderReply = <$TestSocket>;
			print $TestSocket "$$ PING\n";
			my $REPLY = <$TestSocket>;
			chomp($REPLY);
			if ($REPLY eq "PONG") {
				# It's still responding. If the user did this then perhaps he/she wanted
				# to reload the data. Send the reload command
				print $TestSocket "$$ RELOAD_DATA\n";
				print $TestSocket "$$ BYE\n";
				die "Error: A dayplanner daemon is already running and still responding. I told it to reload its data files.\n";
			}
		}
		unlink($DaemonSocket);
				
	}
	$Server = IO::Socket::UNIX->new(
					Local	=> $DaemonSocket,
					Type	=> SOCK_STREAM,
					Listen	=> 5,
			) or die "Unable to create a new socket: $@\n";
	# Trap SIGPIPE
	$SIG{PIPE} = \&SigpipeHandler;
	# Create a new select handle for reading
	$ConnectionSelect = IO::Select->new();
	# Add the main server
	$ConnectionSelect->add($Server);
}

# Purpose: Start the main loop
# Usage: MainLoop();
# Requires: OpenSocket(); already performed
sub MainLoop () {
	# Loop for eternity
	while (1) {
		my $SleepTime = FindSleepDuration();
		# Block until one handle is available or it times out
		my @Ready_Handles = $ConnectionSelect->can_read($SleepTime);
		# Timeout is true if no handle was processed
		my $Timeout = 1;
		# For each handle...
		foreach my $Handle (@Ready_Handles) {
			# We didn't timeout
			$Timeout = 0;
			# If the handle is $server then it's a new connection
			if ($Handle eq $Server) {
				IntDebug("New connection");
				my $NewClient = $Server->accept();
				$ConnectionSelect->add($NewClient);
			} 
			# Handle isn't $server, it's an existing connection trying to tlel us something
			else {
				# What is it trying to tell?
				my $Command = <$Handle>;
				# If it is defined then it's a command
				if ($Command) {
					chomp($Command);
					#			print "COMMAND: $Command\n";
					#print $Handle "okay\n";
					my ($Reply) = CommandHandler($Command);
					#print $Handle CommandHandler($Command),"\n";
					print $Handle "$Reply\n";
				} 
				# If it isn't, then it closed the connection
				else {
					IntDebug("Connection closed");
					$ConnectionSelect->remove($Handle);
					# TODO: Is this needed?
					close($Handle);
				}
			}
		}
		if ($Timeout) {
			DayplannerAlarm();
		}
		if ($Shutdown) {
			IntVerbose($Shutdown);
			unlink($DaemonSocket);
			exit(0);
		}
	}
}

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# INITIALIZATION
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

GetOptions (
	'help|h' => sub {
		print "Day planner daemon version $Version\n\n";
		PrintHelp("", "--dayplannerdir", "Which directory to use as the dayplanner config dir");
		PrintHelp("-h,", "--help", "Display this help screen");
		PrintHelp("-n,", "--nofork", "Don't go into the background");
		PrintHelp("-v,", "--verbose", "Be verbose");
		PrintHelp("-V,", "--veryverbose", "Be very verbose");
		PrintHelp("-d,", "--debug", "Output debugging information");
		PrintHelp("-o,", "--output", "Output all messages to the file supplied instead of STDOUT/STDERR");
		exit(0);
	},
	'debug|d' => sub {
		$DebuggingOutput = 1;
		$OutputVerbose = 1;
		$OutputVeryVerbose = 1;
	},
	'verbose|v' => \$OutputVerbose,
	'veryverbose|V' => sub {
		$OutputVerbose = 1;
		$OutputVeryVerbose = 1;
	},
	'n|nofork' => \$NoFork,
	'f|force-fork' => \$ForceFork,
	'o|output=s' => sub {
		$OutputRedirect = $_[1];
		open(STDOUT, ">$_[1]") or die "Unable to open $_[1]: $!\n";
		open(STDERR, ">$_[1]") or die "Unable to open $_[1]: $!\n";
	},
	'dayplannerdir=s' => sub {
		unless (-e $_[1]) {
			die "$_[1] does not exist\n";
		}
		unless (-w $_[1]) {
			die "I can't write to $_[1]\n";
		}
		$DayplannerDir = $_[1];
	},
) or die "See $0 --help for more information\n";

# Set some settings according to commandline arguments
$DayplannerDir = "$ENV{HOME}/.dayplanner" unless defined($DayplannerDir);
$DaemonSocket = "$DayplannerDir/$SocketName";

# Fork unless NoFork is true
if (not $NoFork or $ForceFork) {
	my $PID = fork;
	exit if $PID;
	die "Unable to fork: $!\nYou may want to try --nofork\n" unless defined($PID);
}

# Verify the dir
die "$DayplannerDir doesn't exist!\n" unless -e $DayplannerDir;
die "$DayplannerDir is not a directory\n" unless -d $DayplannerDir;

# Main
OpenSocket();
LoadCalendar();
MainLoop();
